{"pages":[{"title":"Ray 的朋友们","text":"XD 湛兮酱 艺术+文学+音乐大聚聚 千里冰封 头像和ID每日一换的千里冰冰万里封封 powerfullz 夢縈枯野上 BIE do~ rei~ mi~~~ Rikumi mmwdmm Raptazure 又是PLT聚聚染酱 Edward Evans 40哥 Rachel030219 可爱的小学弟我要瑞秋！ zyf聚聚 域名大概又失效了吧 新一大佬 跑步大佬，非常羡慕！ wayslog 其实是 gayslog 啦 df聚聚 豆腐煲！ 迪龙 现任迪龙跳动公司CEO billow姐姐 好耶！是姐姐（x 北海若聚聚 网上超严肃，其实现实中是一只可爱的瘦宅话痨","link":"/friends/index.html"},{"title":"关于 Ray Eldath","text":"Ray Eldath： 「关于我」页面将被重写。在此之前，欢迎在左侧找到我常用的各种平台。我经常在我的 Telegram Channel 上公开更新技术动态，在 Twitter 上发对生活的各种吐槽。","link":"/about/index.html"},{"title":"","text":"","link":"/js/ray.js"},{"title":"留言板","text":"留下足迹吧！","link":"/messages/index.html"}],"posts":[{"title":"阿尔贝·加缪其人","text":"他在本世纪顶住了历史潮流，独自继承着源远流长的警世文学。他怀着顽强、严格、纯洁、肃穆、热情的人道主义，向当今时代的种种粗俗丑陋发起胜负未卜的宣战。但是反过来，他以自己始终如一的拒绝，在我们的时代，再次重申反对摒弃道德的马基雅维利主义，反对趋炎附势的现实主义，证实道德的存在。 阿尔贝·加缪是蜚声中外的剧作家、文学家和哲学家。因其以荒谬、彻悟和反抗为核心的“荒谬主义” “热情而冷静地阐明了当代向人类良知提出的种种问题” 而获1957年诺贝尔文学奖，获奖时年仅四十四岁。1913年11月7日，加缪出生在阿尔及利亚小镇蒙多维的一个工人家庭，如他自己所述，“赤贫”、“从来是一个无产者”，贫困构成了加缪早年生活的基调；不仅赤贫，失去父亲更使得加缪“孤立无援”，“只能靠一己之力领悟道理，养成独立的人格，成长为一个男子汉”。在这样的环境下，在向他提供无尽财富，沙滩、阳光和大海的贝尔库贫民区，加缪与伙伴们快乐地玩耍、成长、在温热的海水中游泳，在日光之下嬉戏。加缪对那样的时光满怀感激和怀念，这在《第一人》中体现地淋漓尽致：显然，早年的困苦生活并未阻挡这位作家对世界、人类、大地和痛苦的关切，从《鼠疫》中里厄医生和塔鲁初次见面时的长谈，到作品结尾塔鲁那段发人深省的自白，无不表明正是这种困苦，教会这位未来的诺奖得主要善良，要关怀人，要同情人，要有怜悯之心。1924年6月，加缪以一如既往的优异成绩成为家族中第一位有机会就读中学的人；在他的学生生涯中，这位作家与他的小学教师路易·热尔曼从普通的师生关系到忘年交，加缪从未忘记这位指引了他方向、带给了他光明的德高望重的法语特级教师，他共有四部作品、文章献给这位教师，其中包括诺贝尔文学奖答谢词。1937年5月10日，《反与正》出版，标志着加缪正式进入文学界。在加缪不长的文学生涯中，他发表了多部文学、哲学著作和剧本，还在各大进步报刊上声援抵抗组织，并身体力行地承担情报搜集和出版任务，同皮亚、雷诺等抵抗运动战士联系密切。1943年6月，加缪的戏剧《苍蝇》首演，获得极大成功；在首演式上，加缪认识了著名存在主义哲学家萨特，并与之结下友谊，他们经常在咖啡馆讨论政治、哲学和文学，萨特也多次表达对这位“年轻小伙子”的喜爱——直到1951年。1951年10月18日，《反抗者》出版，加缪在该书中提出的新人道主义引发他和萨特长达一年的激烈论战，并以两人的彻底决裂结束。1959年11月，作品《第一人》第一部分初稿完成，他计划在1960年7月完成初稿，并于1961年完成第二稿，或许即是定稿。 但这一切在次年年初戛然而止——1960年1月4日，阿尔贝·加缪乘汽车回巴黎时车祸身亡，享年四十六岁。他的离世给法国知识界带来极大震动，一时间悼念文章铺天盖地。在这些悼念文字中，尤以加缪的前论敌——或许还能称为“前”“前挚友”——萨特的悼词最为感人，也即是本文开头引用的那段话。随着加缪的离去，他所关注的政治问题也走向彻底解决，其哲学讨论亦被人们遗忘，加缪的思想和声音，便逐渐成为已然逝去的历史中一种遥远而模糊的回响。 进入二十一世纪，新的问题和挑战接踵而至。恐怖主义抬头、难民问题、气候变暖，现在还有全球性病毒的空前大流行和根深蒂固的种族歧视：种种危机使迷茫困惑的人们又将目光重新聚焦到这位英年早逝的哲学家上来。半个世纪过去，如今加缪朝思暮想的阿尔及利亚已经独立，二十世纪欧洲知识分子的左倾狂潮也早已过去，那些冷静下来、又一次认识到这位文笔凝炼的作家的文字中蕴含有深刻、富有道德意义和一种伟大的人道主义的哲理的人们，大概不会否认阿尔贝·加缪半个世纪前领悟到的道理，仍闪耀着沉重但轻盈、伟大但平凡的人道主义光辉： 在这儿我领悟了人们所说的光荣：就是无拘无束地爱的权力。 ——阿尔贝·加缪 纪念碑文阿尔及利亚 — 完。— 参考： 《加缪全集》阿尔贝·加缪 《加缪生平与创作年表》李玉民 《论加缪的思想与创作》柳鸣九 《加缪的自我解码》李玉民 以前写的蠢东西… 拿来凑个数好了qvq","link":"/literature/albert-camus/"},{"title":"深入 MIT 6.824：实现 LeaseRead 和全异步 shardkv","text":"「生活，就是当你忙着做其它计划时，发生在你身上的事」：要问起开始学 MIT6.824 的缘由，这是一句恰如其分的描述。一个学期结束，原本的计划是深入研究一下编程语言和形式化验证，然后换到一个和操作系统关系更大的岗位；不知不觉却变成了写个数据库，在做操作系统相关的工作前先试试存储的方向——刚放假时我还对自己说，我是绝对不会喜欢上存储的。也许人们对自己还没下过苦功的事情，就是提不起劲的吧？ 于是春节假期开始，明显一年比一年淡漠的气氛（今年甚至没看拜年祭）环绕，倒也是为思考提供了较好的场所：没有多少亲戚前来拜访，也就没有多少生硬蹩脚的玩笑和紧张尴尬的时刻需要消化。到现在，整一个月，算是把 MIT6.824 彻底完成了。 老实说，这并不如我想象中的难。在上手之前总觉得 824 的高不可攀，非顶尖学府的高手不可；但在自己突然完成之后却发现虽然过程并不是「出乎意料地」顺利，但产出确实是出乎意料地好。 我已开源了这份实现。这一实现稳定通过了 Lab 1 到 Lab 4 的每一个测试点（至少 1000 次，通常 2000 次；其中 Linearizability2B 通过了 10000 次——这么做是因为在提出 porcupine 的文章中，作者说TA “没有找到任何一个线性一致性测试不能发现的错误”），完成了 Lab 4 的两个 Challenges（即标题中的全异步 shardkv），同时还额外实现了 LeaseRead with noop 的优化，使得读请求无需经共识层——本文中提出的解决方案或许是对如何在 MIT 6.824 中实现这一优化的较好参考。另一方面，我谨慎地组织了代码结构，保证代码的粒度适宜——既不引入过多重复，又不引入过多函数（是不是想起了洗试管的原则？嘿嘿），每一次修改都执行了充分的回归测试，并且非常谨慎地操作 squash 和 cherry-pick，保证修改最少、最必要，且和我完成 Lab 的进度严格对应：这意味着读者可以从代码的提交历史中明确看到某个 Lab 和下一个 Lab 之间应要做哪些修改。 &nbsp; 关于头图 头图来自 Twitter@Werlosk。 你可以从以 -test 结尾的测试分支中看到是多么令人沮丧的 debug 过程被隐藏在了 cp &amp; squash 的表象之下： 总体 Lab 的难度大概是 Lab 4B Challenges &gt; Lab 4B &gt; Lab 2 (2C = 2B &gt; 2A &gt; 2D) &gt;&gt; Lab 4A = Lab 3 = Lab 1。 本文将分两个部分，拆解实现中两个较为新颖的侧面：一个是（正如我刚刚提到的）全异步的 shardkv（即 Lab 4 Challenges），另一个是如何实现 LeaseRead with noop 使得读请求无需过共识层（若有机会，本博客兴许会更新完整的实现笔记，而不仅仅是两个较为新颖的侧面）。为不影响各位读者的学习体验，本文将尽可能以「问题情形——解决方法」的形式组织，当你发现无法通过的测试时，你可以阅读一节「问题情形」，在继续阅读「解决方法」之前，你应自行排查自己的实现是否足以排除了这些情形，随后你可以对照相比本文中提出的解决方法而言，你的解决方法有什么不同。 最后，显然的一点是，没有分布式和存储领域的前辈们慷慨无私地分享自己完成这一课程的宝贵经验，这篇文章不可能诞生。特别需要感谢 OneSizeFitsQuorum 的一系列讲解，尽管本文使用的方案与之迥异，却也殊途同归。其它对本文作者很有帮助的参考资料亦附在文末，推荐各位读者前往阅读。本文作者对本文的所有疏漏负全部责任。若有任何问题、讨论（比如，你的解决方法很可能比我的更好，我非常希望你能在评论区告诉我）或建议，欢迎在评论区留言。 &nbsp; 修订日志 EDIT 2022/3/16：更新了「LeaseRead with noop — 优化只读请求（read-only）— wait-free 读」一节中有关 ReadIndex 和 LeaseRead 的表述，使之更加清晰。 EDIT 2022/11/10：修正了「LeaseRead with noop — 优化只读请求（read-only）」一节中有关 LogRead 的描述，并新增了对 QuorumRead 的说明和相关的参考文献。 写在前面或许这段话并不合适出现在一篇标榜为（实际上不一定符合）「深入」的文章中，但还是必须指出几点非常重要的 rules of thumb： 在你启程之前，请确保你已非常认真仔细地阅读了 MIT 6.824 的所有文字指南，包括 locking guide、structure guide 和 student guide； 官方 guidance 中给的日志系统并不是很好用，而且侵入性非常高，我觉得我实现的日志系统（使用 strings.Repeat(rf.me) 来区分不同 node 的日志）是个更简单、更好实现，也极大地帮助了我调试各种离谱问题的方案； 在测试 Lab 3 的两个 speed test（其实我觉得这两个只测写请求的 speed test 非常地没有必要…）时请不要开启 race detector，否则几乎必挂； 如果你发现了莫名高频的锁争用（lock contention）问题，谨记在一个正常的系统里锁争用是非常罕见的情况，请首先检查你的几个常驻循环是否在无等待地无限获取锁（比如，continue 时跳过了 time.Sleep），pprof 的火焰图（flame graph）对调试这一类问题通常很有帮助； 当卡壳的时候，再读一遍课程的几个官方 guidance（尤其是 student guide）和 Lab 描述中的各种 hint；不要觉得参看如本文结尾列出的和本文本身（如我已经指出的那样，本文自愧远远不如分布式和存储领域的前辈们攥写的那些经验总结们优秀）这些总结是一件难以接受的事，诚然自己从零开始会更有成就感，但站在前人的肩膀上也一样有趣； 在实现 Lab 3 之前一定要先看课程的 Guest Lecture，Golang 的发明人 Russ Cox 在那个课上介绍了很多与 Lab 3 和 Lab 4 实现直接相关的并发 idiom），并且要注意检查你的实现有没有内存泄漏和协程泄漏的问题（我并不保证我的实现没有这些问题，因为我并没有仔细检查过…呜呜呜）。 现在，我将默认你已理解 Raft 算法的精髓，并已清楚如何在共识层上搭建真正的应用程序。 让我们开始吧。 全异步 shardkvLab 4B 无疑是难度最大的。相比有示例结构和明确参考的 Lab 2 raft，Lab 4B 要求大家从零开始设计分片的 KV 数据库，从头设计必须实现的分片移交（shard handoff）机制，没有任何示例和文字描述可做参考，还要保证这一机制不会违背线性一致性。 Lab 4 附有两个 challenges，分别要求我们实现失效数据的清除（Challenge 1）和异步变更配置的 shardkv（Challenge 2）。首先需要强调的一点是，如果你希望实现异步变更配置的 shardkv（也就是完成两个 challenges），一定要从设计的最初始就考虑这样做。 我们先来思考一下 challenge 2 到底是什么意思。Lab 4 中要求我们实现一个分片的分布式键值数据库，其核心是当配置变更（也就是从切片（shard）到组（replica group）的映射关系发生变化）时集群要同步反映这些变更：原先负责这个切片的组应不再负责这个切片，而新被分配这个切片的组应开始服务，并且要在和原组相同的数据上继续。在切片移交（handoff）的过程中不能接受客户端请求。 一个非常显然的实现就是同步的实现：我们编写一个新的常驻 goroutine，这个协程定期更新配置并计算变更（diff），如果发现变更，停止所有的客户端请求和整个 applier，移交切片并更新配置，待所有切片都就绪后才恢复客户端请求和 applier 循环。 这种简单的做法无疑效率低下。原因有二：首先，一个组会负责多个切片，而配置变更时需要移交和同步的切片通常只是一个组负责的多个切片的一部分。举一例：在配置变更 {1 [100 102 101 101 102 100]} -&gt; {2 [100 100 100 101 101 101]} 中，组100负责从负责切片 [0 5] 变更至负责切片 [0 1 2]，其中只需要同步 [5 1 2]，而切片0在整个过程中都可以不中断服务，上述同步实现显然做不到这点；其次，一次变更可能需要来自不同组的多个切片，而一个切片可以在收到移交的数据时就立即开始服务，无需等待别的移交。还是上面的例子，变更配置时组100需要来自组102的切片1和组101的切片2，一旦收到来自组102的切片1，这一切片就能立刻开始服务。 所以，要完成 challenge 2，我们需要将配置更新、分片移交和分片恢复服务三个阶段完全异步化。当检测到配置更新时，仅仅停止需要同步的切片，不能阻塞客户端请求和 applier 循环；此后移交切片，并且在收到对应切片时立即恢复对该切片的服务。 已有的众多实现都采用了 “拉切片” 的同步方法（甚至连测试也暗示了这点… shardkv 的 TestConcurrent2 测试点上边的注释写的是 fetch shard contents…）。即当检测到配置变更时，由新被分配某个切片的组向它的「前辈」去 “要” 切片，相关的文章通常宣称这样的做法会更简单，尤其是在需要从宕机（crash）中恢复的若干场景下。 本文质疑这种说法。本实现证明了使用 “推切片” 的同步方法亦是可行的，两者间并无显著的复杂度区别，无论是就 RPC 次数还是宕机恢复逻辑的复杂程度而言。本节余下部分谈论的「问题场景」对 “拉切片” 依然适用，且要在那种同步方法中解决所有这些问题很可能需要相似的机制。鉴于两者并无显著的复杂度差异，各位读者可任意地自由选择同步方法。 分片异步移交（async handoff）协议需要强调的是，shardkv with challenges 的要点是江配置更新、分片移交和分片恢复服务这三个部分完全解耦并使之异步化。任何实现方案都要做到这些，而此处给出的方案只是若干可行解中的一种。 在 Lab 4A 中我们已经实现了负责提供一致 Config 的 shardctler，而 Lab 4B 的 shardkv 泽通过 shardctler.Clerk 与其定期通信并拉取配置。注意到从配置更新到分片恢复服务之间有若干阶段，每个阶段间都有可能发生宕机和换主，请确保你的实现能够处理各种情形（在下文「问题场景」和「解决方法」将更多地涉及具体的错误场景），这首先要求每个节点对当前配置和「更新步骤进行到哪个阶段」要有一致的认识。 因此，整个 reconfiguration 过程的大部分逻辑应在 applier 循环中实现。对于一轮 reconfiguration，集群异步地按三个步骤工作，并依赖 Raft 层实现状态的一致转移： 更新配置：首先 Leader 会定期拉取配置。当发现配置的 Num 比本地配置更大且所有分片的状态都是正常状态时，调用 Raft 层 Start。对应示意图中 DoUpdateConfig。 更新配置：接下来由包括 Leader 在内的每个节点的 applier 循环接收自 Raft 层推送的最新配置，由这个最新配置更新当前配置、计算 diff 并据此更新每个分片的状态（这个接下来还会讲到），同时开始分片移交（handoff）。对应示意图中 applyConfig（这是一个由 applier 循环根据消息类型调用的方法）。 移交分片：接收到移交（handoff）消息的组的 Leader 调用 Start，成功后向原组发送移交成功消息。对应图中 Handoff。 移交分片：每一个节点的 applier 循环接收移交消息并对应更新自己的 kv map。对应图中第一个 applyMsg。 分片恢复服务：当原组的 Leader 收到分片移交成功消息后，调用 Raft 层的 Start。对应图中 HandoffDone。 分片恢复服务：包括 Leader 在内的每个节点的 applier 循环接收自 Raft 层推送的配置更新完成消息，清理对应的 key（Lab 4 Challenge 1）并将这些切片恢复到正常状态，为下一轮 reconfiguration 做准备。对应图中第二个 applyMsg。 示意图如下：（我知道我的字很丑，请别喷我… 呜呜呜呜 🥺🥺🥺） 注意到在一次 reconfiguration 的流程全部完成之前不会更新下一个配置，因为在最后一步恢复分片状态前一定有分片的状态不是正常状态，而当有分片是非正常状态时步骤1不会启动。 可以看到整个 reconfiguration 过程还是比较复杂的，并且有若干细节问题需要仔细考虑，这会在下文中详述。由于本节只对总体设计做概观式的鸟瞰，以下仅再简要讨论三个问题： 问题1：分片状态第一个问题是，上文不断提到分片除了 Config 中给出的 shard -&gt; gid 对应关系外，还有一个额外的「状态」需要维护。分片有哪些状态？应该如何管理这些状态？ 当一个组的节点接收到 Raft 层推送的最新配置时，要计算 diff 并更新分片状态（第2步），对于一轮 reconfiguration，切片移交的发送方和接收方都会这么做，从而产生两种可能：一个分片从别处移给我，一个分片从我这交给别处。算上正常状态，一共有三种状态：Serving、Pulling 和 Pushing。注意到在这三种状态下都是不能提供服务的。 另外是如何管理这些状态。一种方案是约定特殊的 Config.Shards 值，比如 -1 表示 Pushing、-2 表示 Pulling，这样做可能会给 diff 算法引入额外的复杂度，并且更新 Config.Num 的策略（是当所有特殊值都消除时才更新 Num 吗？）还会引入别的问题。更好的方案是在 Config 之外维护一个额外的 ShardState 数组，并通过 Golang 的常量枚举语法提升代码的可读性： shardkv/server.go12345678910111213type ShardKV struct { // ... omitted config Config shardStates [shardctrler.NShards]ShardState}type ShardState intconst ( Serving ShardState = iota Pulling Pushing) 问题2：RPC 消息类型和 RPC handler 的个数在上文的步骤描述中，出现了两个 RPC handler 和两对共四种 RPC 消息：用于移交分片的 HandoffArgs 和 HandoffReply，以及用于完成分片移交的 HandoffDoneArgs 和 HandoffDoneReply。 你可能会觉得，一个 RPC handler 可以既处理发出去的请求又处理回来的回复，所以只用一个 RPC handler 和一对 RPC 消息 func Handoff(args *HandoffArgs, reply *HandoffReply) 就能解决问题。这样做是行不通的。具体原因请见下文「问题场景」一节。 问题3：持久化最后一个问题是哪些状态应该被持久化。如上所述，从配置更新到分片恢复服务之间有若干阶段，每个阶段间都有可能发生宕机和换主，所以请务必仔细考虑有关持久化的问题，在本部分的剩余几节会更加详细地讨论之。 对 reconfiguration 的整个流程的鸟瞰式概括就到此结束了。如果你还没有开始动手完成 Lab 4B，为达到最好的学习效果，你应关掉本文，开始自行编写实现，并仅当遇到难以解决的问题时（确保你已经足够努力地 debug）继续阅读本文的剩余部分。 问题场景在设计并实现（主要是设计）上面的流程中遇到了若干问题，其中有一些问题的解决方法并没有详细包含在上述流程中，主要是因为显然由读者自行发现这些问题并自行思考解决的机制将更加有益。本节将总结我在设计和过程中遭遇的若干会引起问题的场景，需要注意这并不一定覆盖了所有可能的问题场景，而仅仅是我遇到的。在本文的余下部分，称一次移交的发送方为 “源组”，接收方为 “目标组”。 第一类是与分片移交机制本身相关的场景，共有四种： a. handoff lost update 组100发起移交，随后该节点宕机（Z字型线表示节点宕机）。接收组完成了更新并开始服务请求，而源组的新 Leader 又发起了一次移交，接收组应用已经应用过的移交，造成状态回退。 b. lost handoff done 组100发起移交，随后该节点宕机。接收组完成更新并返回移交成功消息，由于源组的原发送节点已经宕机，导致它无法向 Raft 层提交移交完成的消息，造成思索死锁。 c. lost handoff 组100的原 Leader S0 通过步骤1和步骤2在组内更新完配置，正准备发起移交时宕机了，新选出来的 Leader S1 以为原 Leader 已经发送了移交，于是一直等待移交完成消息，造成死锁。 d. lost config 组100的 Leader S0 完成了步骤1并在步骤2前恰好宕机，而 S0 恢复后一开始不是 Leader，从 Raft 层传来的 Config 不会触发移交，从而丢失了一次 reconfiguration。 还有一类场景是与消息去重相关的，但这与去重机制的具体实现相关，在此不再赘述。 解决方法 &nbsp; Spoiler Alert 本节包含大量 “剧透”，可能影响你的学习体验。 我谨慎控制了剧透程度使之影响不至于过分严重，故本部分给出的代码脉络大多不太完整，仍有不少需要思考的细节。 解决问题场景 a. handoff lost update 或许简单的去重就能解决这个问题，然而这必须在同一个组的每个节点都使用相同的 ClientId 时才行得通。我并没有使用这种方法（或许这样做会更简单，欢迎尝试了这种方法的读者在评论区指出其优劣）。我的解决方法是在应用状态前增加两下检查：首先检查在移交的分片对应本地状态中，是不是有 Pulling 状态的分片，如果没有则明显说明这是一个重复的移交。然而这样做并不足够，因为在目标组收到重复移交之前可能已经进行了下一轮 reconfiguration，所以还需要检查 HandoffArgs.Num 是否是最新的。 b. lost handoff done 这就是在问题2中提到的不能使用一对 RPC 消息和一个 RPC handler 就搞定移交的原因。这里的问题本质上是当一个节点需要对某个 RPC 的回复达成共识时，回复可能被网络延迟太久以至于到达时该节点已不再是 Leader，无法调用 Start。设计复杂的 RPC 协议并不能解决这个问题而只是延后了问题。解决方法其实很简单，上文也已提到：使用多一对 RPC 消息和多一个 RPC handler 来传递「完成操作」的信息，并且信息的发送方要轮询接收方直至成功发送（「完成操作」消息的接收方也就是「操作」消息的发送方）。注意，在配置更新后，「操作」消息发送方的地址可能会被丢失。 另外一点是所有依赖 RPC 回复的 Start 调用都会出现这个问题，你的实现可能以别的形式（而不是情形b）引入了它。 c. lost handoff 该场景有显然的解决方法，在此概不赘述。 d. lost config 这是一个有点意思的场景，应该有多种解决方法。我的方法是在步骤1传入 Raft 层的 shardctler.Config 之外额外包一层，一并传入「是哪个节点提交的这个 shardctler.Config」，当收到 Raft 层推送的配置时，如果这个值和本节点的编号匹配，则无视本节点可能不是 Leader，立即发起移交： shardkv/server.go1234567891011121314151617181920212223242526272829303132333435363738394041type Config struct { Conf shardctrler.Config Committer int}func (kv *ShardKV) DoUpdateConfig() {updateConfig: for { time.Sleep(UpdateConfigInterval) if !kv.isLeader() { continue } for _, state := range kv.shardStates { if state != Serving { kv.mu.Unlock() continue updateConfig } } num := kv.config.Conf.Num + 1 kv.mu.Unlock() kv.rf.Start(Config{kv.mck.Query(num), kv.me}) }}func (kv *ShardKV) applyConfig(latest Config, commandIndex int) { if commandIndex &lt;= kv.lastApplied { return } // ... kv.updateShardStates()}func (kv *ShardKV) updateShardStates() { latest := kv.config handoff := make(map[int][]int) // gid -&gt; shards for shard, gid := range kv.lastConfig.Conf.Shards { // ... calculate diff } if kv.isLeader() || kv.me == latest.Committer { kv.handoff(handoff, latest.Conf, kv.copyDedup()) }} 去重如何去重和如何移交去重表会带来很多问题，但是只要你使用了合适的去重方案，这一切都会变得十分简单。我推荐的方案是使用 SequeceNum 对消息进行去重（客户端的每个请求都要带 ClientId 和递增的 SequenceNum，且仅在服务器返回 OK 时递增 SequenceNum），这会使得解决各种与去重（和移交去重表）相关的问题变得非常容易。我一开始是用随机而非递增的 RequestId 进行去重，导致用于消息去重的数据结构比较复杂，遇到了很多问题，移交去重表的流程也很麻烦。 另外一个有关去重的细微问题是如果使用 SequenceNum 机制去重请求，那么客户端必须只有一个 goroutine 访问 SequenceNum 这个状态（不能存在并发）。如果是 Clerk 这很容易做到，但是对于移交分片的服务器到服务器通信则需要额外的机制。我使用了一个 handoffCh 通道和的一个常驻的 goroutine 协程来保证这点，这应该还算是一个不错的结构： shardkv/server.go123456789101112131415161718func (kv *ShardKV) DoPollHandoff() { for handoff := range kv.handoffCh { handoff.args.Args = Args{ClientId: kv.cid, SequenceNum: kv.num} nextHandoff: for { for _, si := range handoff.servers { var reply HandoffReply ok := kv.sendHandoff(si, &amp;handoff.args, &amp;reply) if ok &amp;&amp; reply.Err == OK { kv.num++ break nextHandoff } if ok &amp;&amp; reply.Err == ErrWrongGroup { panic(&quot;handoff reply.Err == ErrWrongGroup&quot;) } } time.Sleep(UpdateConfigPollInterval) } }} 思考一下 handoffCh 应该是 buffered 还是 unbuffered channel？如果是 buffered channel，那么它应该有多大？ 代码结构本节将简要介绍本实现的代码结构。毫无疑问将这整个可以说是相当复杂的分片移交协议实现得简洁、清晰、易于维护，并不是一件轻松的事。 本节描述的代码结构可参看分片异步移交协议一节中的示意图。 由于无论是 shardkv 还是 Raft 协议本质上都是一个巨大的事件循环（event loop），所以使用常驻 goroutine 中的无限循环对各种事件进行响应就自然成为了一个合适的方案。启动时，StartServer 会启动三个常驻 goroutine： DoApply：Raft 层 apply log 事件循环，监听 applyCh。 DoUpdateConfig：仅 Leader 有效，不断轮询 shardctler 并将最新 Config 推入 Raft 层。 DoPollHandoff：如上所述，使用 SequenceNum 进行去重时需要保证只有一个 goroutine 会访问 SequenceNum 状态，这就是那个 goroutine。它监听 handoffCh，发送请求并递增 kv.num。 在分片异步移交协议一节中，我们介绍了本全异步 shardkv 实现使用的「基于推操作」的分片移交协议，以及该协议需要哪些 RPC handler。RPC handler 共有两个： shardkv/server.go1234567891011121314151617181920func (kv *ShardKV) Handoff(args *HandoffArgs, reply *HandoffReply) { if !kv.isLeader() { reply.Err = ErrWrongLeader return } _, reply.Err = kv.startAndWait(&quot;Handoff&quot;, *args) if reply.Err == OK { var doneArgs HandoffDoneArgs // ... initialize doneArgs go kv.pollHandoffDone(doneArgs, args.Origin) }}func (kv *ShardKV) HandoffDone(args *HandoffDoneArgs, reply *HandoffDoneReply) { if !kv.isLeader() { reply.Err = ErrWrongLeader return } _, reply.Err = kv.startAndWait(&quot;HandoffDone&quot;, *args)} startAndWait 是一个所有的 RPC handler 都要调用的方法：它调用 raft.Start，然后阻塞，直到 DoApply 循环通过 doneCh 通知该操作已完成时再返回： shardkv/server.go12345678910111213141516171819type Done chan GetReplyfunc (kv *ShardKV) startAndWait(ty string, cmd interface{}) (val string, err Err) { i, _, isLeader := kv.rf.Start(cmd) if !isLeader { return &quot;&quot;, ErrWrongLeader } ch := make(Done, 1) kv.doneMu.Lock() kv.done[i] = ch kv.doneMu.Unlock() select { case reply := &lt;-ch: return reply.Value, reply.Err case &lt;-time.After(TimeoutInterval): return &quot;&quot;, ErrTimeout }} 如步骤1所述，常驻 goroutine DoUpdateConfig 在条件适宜时将最新的 Config 推送至 Raft 层，一切顺利的话这个最新的 Config 将从 raft.applyCh 中推送至 shardkv 的 DoApply 事件循环。DoApply 中包含了整个 shardkv 的绝大部分处理逻辑： shardkv/server.go123456789101112131415161718192021222324252627func (kv *ShardKV) DoApply() { for v := range kv.applyCh { if v.CommandValid { if latest, ok := v.Command.(Config); ok { kv.applyConfig(latest, v.CommandIndex) } else { val, err := kv.applyMsg(v) if kv.isLeader() { kv.doneMu.Lock() ch := kv.done[v.CommandIndex] kv.doneMu.Unlock() if ch != nil { ch &lt;- GetReply{err, val} } } } if kv.maxraftstate != -1 &amp;&amp; kv.rf.GetStateSize() &gt;= kv.maxraftstate { // ... do snapshot } } else if v.SnapshotValid { if kv.rf.CondInstallSnapshot(v.SnapshotTerm, v.SnapshotIndex, v.SnapshotSeq, v.Snapshot) { kv.readSnapshot(v.Snapshot) } } }} DoApply 在收到一条 Raft 层推送的消息后，首先判断消息类型。如果是 Config，通过 applyConfig 应用状态变更并执行步骤2；如果是一般请求（Get 和 PutAppend）和分片移交消息，则通过 applyMsg 方法应用状态变更并执行协议的步骤3（对于 HandoffArgs）或步骤6（对于 HandoffDoneArgs）。当这一切完成后，通过 kv.done 结束对应 RPC handler 阻塞并返回。 applyConfig 方法则严格执行了步骤2，在上文已经给出过这段代码的脉络了。注意到实现需要正确处理场景d，且对于一些实现而言要如何优雅地（最大代码复用）解决场景c也需要一些思考。该方法末尾调用的 handoff 方法将当前消息推送到 handoffCh 中，由于在去重一节中描述的问题，我们需要使用常驻 goruotine DoPollHandoff 轮询目标组并发送分片移交消息，该方法的代码结构已在上文中给出过了。 而 applyMsg，如你猜测的那样，这个方法 is nothing but a giant switch： 12345678910111213141516171819202122232425262728293031323334353637383940func (kv *ShardKV) applyMsg(v raft.ApplyMsg) (string, Err) { if v.CommandIndex &lt;= kv.lastApplied { return &quot;&quot;, ErrTimeout } kv.lastApplied = v.CommandIndex switch args := v.Command.(type) { case GetArgs: // ... handle Get return kv.kv[key], OK case PutAppendArgs: // ... handle PutAppend return &quot;&quot;, OK case HandoffArgs: // ... do some check for k, v := range args.Kv { kv.kv[k] = v } for _, shard := range args.Shards { kv.shardStates[shard] = Serving } for cid, dup := range args.Dedup { if dup &gt; kv.dedup[cid] { kv.dedup[cid] = dup } } kv.dedup[args.ClientId] = args.SequenceNum return &quot;&quot;, OK case HandoffDoneArgs: // ... do some check for _, k := range args.Keys { delete(kv.kv, k) } for _, shard := range args.Shards { kv.shardStates[shard] = Serving } return &quot;&quot;, OK default: panic(&quot;uncovered ApplyMsg&quot;) }} 在代码中有两处省略的 // ... do some check，需要仔细考虑应该进行哪些检查、返回哪些错误。注意返回的不同错误 ErrWrongLeader、ErrWrongGroup 和 ErrTimeout 会导致客户端的不同行为。请谨慎思考在什么情况下返回哪种错误才能既不违反协议又不引入死锁。 LeaseRead with noop在写这篇文章时我总觉得读者们早已熟悉本文的第一部分，而这一部分可能才是大部分读者关注的主题（只是一个猜测）。在那篇大名鼎鼎的 [Ongaro 2013] 论文（也就是课程给定的那篇论文）的第八节 8. Client Intersection，Ousterhout 教授（此人还是 A Philosophy of Software Design 这本很棒的书的作者，同名的 Talks at Google 讲演也非常棒）提了这么一段话： Read-only operations can be handled without writing anything into the log. However, with no additional measures, this would run the risk of returning stale data, since the leader responding to the request might have been superseded by a newer leader of which it is unaware. Linearizable reads must not return stale data, and Raft needs two extra precautions to guarantee this without using the log. First, a leader must have the latest information on which entries are committed. The Leader Completeness Property guarantees that a leader has all committed entries, but at the start of its term, it may not know which those are. To find out, it needs to commit an entry from its term. Raft handles this by having each leader commit a blank no-op entry into the log at the start of its term. Second, a leader must check whether it has been deposed before processing a read-only request (its information may be stale if a more recent leader has been elected). Raft handles this by having the leader exchange heartbeat messages with a majority of the cluster before responding to read-only requests. Alternatively, the leader could rely on the heartbeat mechanism to provide a form of lease [9], but this would rely on timing for safety (it assumes bounded clock skew). 寥寥几笔便道尽了本部分的主角。首先，正如论文作者在第一节 1. Introduction 指出的那样，Raft 协议的一大特点就在于该协议是被切分成了几个独立（在研究和实现的双重意义上）的部分，而每一部分都有诸多实现方法和优化。这些优化大多关注我们经常用「性能」一词模糊地一言以蔽之的两个不同方面：其一是可用性（availability，或 liveness），比如改善在网络不稳定下的选举过程的 PreVote 算法；其二是吞吐量（throughput），它关注对于不同请求类型，如何提高集群对它们的处理能力——比如本部分将要涉及的 LeaseRead，就是如此。 优化只读请求（read-only）据我在这一领域十分粗且一知半解的了解，对 Raft 协议的只读请求的实现方法，主要有以下几种： LogRead，没有任何优化，每一个 Get 请求都要由 Leader 发起、在整个集群内部达成共识，这也就是课程 Lab 要求的实现方式。 ReadIndex，基本思路是在收到只读请求时首先记录当前 commitIndex 为 readIndex，然后发起一轮心跳确认自己还是 Leader，最后等待本地 lastApplied &gt; readIndex 并返回结果。这种方法由 Leader 直接在本地服务只读请求，不需写日志，但仍然需要一轮心跳。 注意，仅在一些情况下才需要记录 + 等待的额外步骤。若无需等待，则任何一个只读请求都能在访存后直接返回，无需与共识层交互，并且具有所谓 wait-free 的良好性质，关于这个问题的更多内容请见下文。 LeaseRead，这就是论文中简要提及的优化，也即本部分的主角。实装此优化时，每个 Leader 在每一轮心跳获得多数 Success: true 后则获得一个租约（lease），过期时间是发起这轮心跳的开始时间（思考一下，为什么？）加上一个固定值（LeaseDuration）。需要保证在本 Leader 的租约过期前不会换主（LeaseDuration &lt; ElectionTimeout），同时在租约过期后本 Leader 不应继续服务。 FollowerRead，广义的字面含义指一切使读请求能由 Follower 响应的优化，即 QuorumRead（很快就会讲到）是 FollowerRead 中的一种。在这里我采用了 TiDB 文档（这也是这个词的最常见语境）中对 FollowerRead 的狭义定义：Follower 在响应读请求前需要先向 Leader 询问他的 commitIndex，然后在本地等待 lastApplied &gt;= readIndex，这本质上和 ReadIndex 并无太大差别。注意在这个过程中虽然号称 “FollowerRead” 但其实仍需 Leader 的参与；虽然依赖的程度有所降低，但和上述几种优化一样，读请求同样单点地依赖 Leader，导致读请求的可扩展性（scalability）依然受限。 有一种对 FollowerRead 的进一步改进是向除 Leader 外的多数节点询问 commitIndex，这样是否可以避开 Leader 服务读请求呢？答案是否定的。原因其实很简单，我将这点留给读者思考，欢迎在评论区给出你的答案 :-)。 为了进一步提高集群的可扩展性，[Arora 2017] 中提出了 QuorumRead（在论文中称作 Strongly Consistent Quorum Reads），可使读请求完全由 Leader 之外的节点响应，从而彻底解决了对 Leader 的单点依赖。但这一方法对底层的数据模型提出了限制，它要求每个数据都必须附带版本号或时间戳（timestamp），虽然在很大一部分 Raft 共识算法的应用场景下（如 MVCC）这点是成立的，但 MIT 6.824 Lab 并不属于其中之一，且本节仅讨论较通用的优化方法，故在此不作讨论。 如果要做一个非常华为的对比图，这四种算法分别就是： 只读（read-only）请求服务算法 能由 Follower 响应？ 无需心跳？ 无需写日志？ LogRead 😐 😐 😐 ReadIndex 😐 😐 😃 LeaseRead 😐 😃 😃 FollowerRead 😃 😃 😃 当然，上边的对比还不完全华为的一点缺陷就是，该表格反映了真实情况（ 注意到，上面的四种算法需要提供的核心保证只是，Leader 在服务某个只读请求时还是 Leader。无论何种优化都只是以更有效率的方式提供这条保证，否则在网络分区的场景下就会违背线性一致性。 还有一点需要注意的是，相比 ReadIndex 而言，LeaseRead 引入了对时钟偏斜（time skew）的依赖，这要求集群内的各个节点的时钟必须以近似的速率滴答。由于这个额外的限制，etcd 的共识层默认是基于 ReadIndex 算法的（ReadOnlySafe），但提供了一个选项可供用户切换至 LeaseRead 算法（ReadOnlyLeaseBased）；但 TiKV 却是默认实现的 LeaseRead 甚至是 FollowerRead，总的来说这需要具体问题具体分析。 wait-free 读另外一点问题是，网上对于 ReadIndex 的描述大多都提到了「记录当前 commitIndex 为 readIndex，随后等待本地的 lastApplied &gt;= readIndex 时才能查询并返回请求」（见 [Ongaro 2014]）这一额外的「延迟查询」步骤，但却鲜有文字介绍这一步骤的原因和必要性。 小专栏：non-blocking 和 wait-free non-blocking 和 wait-free 是两个用于描述「无需等待」这一良好性质的常见概念。注意它们之间的区别：前者指对于一组并发的访问，其中有至少一个能在有限步内完成；而后者指这组并发访问中的每一个都能在有限步内完成，显然后者是一个更好、也更难达到的性质。另一个词 lock-free 经常被视作是 non-blocking 的同义词，这是不够准确的，一个算法没有使用互斥锁并不代表它就能保证至少一个进程能在有限步内完成。比如直接使用 CAS 实现的并发访问（这满足一般理解中「lock-free 无锁」的含义）如果没有随机化 backoff 时间，仍然可能出现永久等待的情况。更加详细的描述参见 [Valois 1994]。 注意到一个实现是 wait-free 的并不意味着它就一定比 non-blocking 的实现在算法意义上更优。有可能仅仅是它的一致性性质更弱，或暴露的接口更低级，这有点类似 Chubby 和 ZooKeeper 之间的关系（[Hunt 2010]）。 对于 FollowerRead，如果 Follower 在处理只读请求前不询问并等待当前 Leader 的 commitIndex，那么显然会破坏线性一致性。因为即便一条日志已经被提交，由于提交是异步的（提交仅仅说明前移了 commitIndex，但是要等这些条目都应用到状态机中，还要等 applier 循环异步地逐个递增本地 lastApplied，直到 lastApplied &gt;= commitIndex），可能出现一个条目 Follower 先应用而 Leader 后应用的情况，所以具有 wait-free 性质的 FollowerRead 实现不满足线性一致性。 而对于 ReadIndex 和 LeaseRead 优化，如果读和写请求都由 Leader 处理，并且一个写请求直到被应用到状态机（apply）后才会回复，那么去掉等待步骤仍然满足线性一致性，且具有只读 wait-free 的良好性质。因为一个写请求在应用后才会返回，那么之后的读请求一定可以（如果你的锁协议没有炸掉的话）读到最新的写，而并行的写和读无论是否读取到和它并行的写的结果都是满足线性一致性的。所以只要读和写都由 Leader 处理、且写仅在 apply 后才予以回复，那么 ReadIndex 和 LeaseRead 优化的 wait-free 实现都满足线性一致性。 有些读者可能会疑惑为何 ReadIndex 和 LeaseRead 的 wait-free 实现无需担心 Follower 和 Leader 的 applier 循环间不同步的问题（这个问题导致 wait-free 的 FollowerRead 不满足线性一致性）。原因是在 ReadIndex 和 LeaseRead 优化中读写都是由当前的有效 Leader 处理的，而新 Leader 上任时会提交 noop 从而保证新 Leader 的 lastApplied 至少和老 Leader 的一样大。 本实现是只读请求 wait-free（访存后直接返回）的 LeaseRead 优化。 注意到这里其实还有若干细节问题没有讨论，在下文中将逐一涉及。 LeaseRead with noop和很多文章描述的情形不同，实现这一优化的工程量并没有很大，事实上大部分修改都紧凑而有条理。引入 LeaseRead with noop 需要引入两个部分，首先是 LeaseRead，其次是 noop。（怎么感觉这话就很有搁这搁这那味。。。） 引入租约机制并不复杂，主要的修改只有寥寥数行： 12345678910111213141516171819202122diff --git a/src/raft/raft.go b/src/raft/raft.goindex 361c15d..367308a 100644--- a/src/raft/raft.go+++ b/src/raft/raft.go@@ -838,7 +884,15 @@ func (rf *Raft) Sync(peer int, args *AppendEntriesArgs) {rf.resetTerm(reply.Term)} else {if reply.Success {+ lease.leaseVote+++ if rf.IsMajority(lease.leaseVote) {+ if rf.leaseEndAt.Before(lease.leaseEndAt) {+ rf.leaseEndAt = lease.leaseEndAt+ }+ }@@ -172,7 +185,10 @@ func (rf *Raft) GetState() (int, bool) {rf.mu.Lock()defer rf.mu.Unlock()term = rf.term- isleader = rf.state == Leader+ isleader = rf.state == Leader &amp;&amp; !rf.leaseSyncing &amp;&amp; time.Now().Before(rf.leaseEndAt)return term, isleader} lease 是在一轮心跳发起时生成的，此外需要避免租约的到期时间发生回退。 noop 的引入则要更有意思一些。由于课程的测试套件要求日志的 Index 是密集的，而提交的 noop 会破坏这点。我的方法是引入一个新的 Seq 参数，当 DoApply 循环推送日志给上层服务时将 Seq “假装”成 Index，但仅当处理请求（而非 noop）时 Seq 才会递增，满足 Seq &lt; Index。 这一方案乍看起来没有什么问题，但当需要 Snapshot 时就会犯难。 由于当接收到 InstallSnapshot 时需要设置 log[0] 的 Seq 值，所以要实现 noop 需要变更 CondInstallSnapshot 对外暴露的方法签名，也就意味着需要对测试套件做一点小小的修改。好在课程的测试套件编写得相当清晰，只需两行修改就能达成目标： 123456789101112131415161718192021222324diff --git a/src/raft/config.go b/src/raft/config.goindex f17f092..9895291 100644--- a/src/raft/config.go+++ b/src/raft/config.go@@ -185,7 +185,7 @@ func (cfg *config) applierSnap(i int, applyCh chan ApplyMsg) {//DPrintf(&quot;Installsnapshot %v %v\\n&quot;, m.SnapshotIndex, lastApplied)cfg.mu.Lock()if cfg.rafts[i].CondInstallSnapshot(m.SnapshotTerm,- m.SnapshotIndex, m.Snapshot) {+ m.SnapshotIndex, m.SnapshotSeq, m.Snapshot) {cfg.logs[i] = make(map[int]interface{})r := bytes.NewBuffer(m.Snapshot)d := labgob.NewDecoder(r)@@ -193,8 +193,8 @@ func (cfg *config) applierSnap(i int, applyCh chan ApplyMsg) {if d.Decode(&amp;v) != nil {log.Fatalf(&quot;decode error\\n&quot;)}- cfg.logs[i][m.SnapshotIndex] = v- lastApplied = m.SnapshotIndex+ cfg.logs[i][m.SnapshotSeq] = v+ lastApplied = m.SnapshotSeq}cfg.mu.Unlock()} else if m.CommandValid &amp;&amp; m.CommandIndex &gt; lastApplied { 我已经听到读者大佬们当发现原来还要改测试套件时不屑的嘘声了（ 问题场景 &amp; 解决方法即便已给出了算法概览，要真正实现并通过测试还是会遇到若干问题。本节将简要列举这些问题并给出我的解决方法。 第一点需要注意的是，一个 Leader 在上任前会提交一个 noop，这可能会导致此前还未提交的条目被提交并应用。在这一过程中不能服务任何请求（包括只读请求），因为这中间的状态不能被外界观察到。我们可以通过引入一个额外的 leaseSyncing 状态并修改 GetState 的语义来实现这点限制：isleader = rf.state == Leader &amp;&amp; !rf.leaseSyncing &amp;&amp; time.Now().Before(rf.leaseEndAt)。leaseSyncing 在节点转为 Leader 并提交 noop 时置为 true，并仅当 commitIndex &gt;= lastApplied 才关闭 leaseSyncing。 这里还有一点细节：并不是只有 applier 循环才会递增 lastApplied。你需要检查代码中各处对 lastApplied 的修改是否需要检查并关闭 leaseSyncing，漏掉一个就有可能导致 GetState 一直返回 ErrNotLeader 而引起死锁。 第二点问题是，由于我实现的 LeaseRead 改变了 GetState 和 needApply 的语义，这有可能引入另外的死锁问题。比如， applier 循环应该提供的保证是只要一个请求被提交，那么它最终就一定会被应用；如果你的 needApply 考虑了租约，那么可能出现一个条目在 Start 时租约有效、但之后由于租约过期、又没有新的写请求而一直无法被应用的情形，从而导致死锁。总的原则是你需要保证在 GetState 返回 true 时提交的请求最终也一定会被应用。注意到由于一个有效的 Leader 会不断续期租约，所以通常这只需要更频繁地检查 applier 循环的触发条件就能解决。 结语身处一个氛围并不太好——真正的双非学校，大家都在卷考研 / 卷大厂，没有人关心技术本身以及这些「没什么用」的知识——的环境，很多时候我们只有自己。我曾多次想与人讨论自己从文献中冥思苦想得来的 eureka 而无人回应，也感到自己在技术上的存在一直是靠网络维持。不过，或许还是有少数人同行，而能在现实中认识思想开明的朋友是一件十分幸运的事：感谢室友们在我激动兴奋之时的耐心倾听（有时还会回应，不得不说其中很多想法颇有见地），尽管他们对我的话题并无太大兴趣，但却真切反映了许多值得欣赏的品质。 所以对于在同学间（尤其是学弟学妹间）时常爆发的有关我们这双非和他们那双非孰优孰劣（通常还伴随着自己来了这里是不是亏了）的讨论，我通常不屑一顾。要真论教学（其实很有可能主要的限制因素反而是学生的水准），只要没有达到 211 和 985 的级别大概都难分高下，而在这种情形下只能祈望学校管理宽松：如果你难以提供高质量的教学，至少不要阻止学生们另寻出路。 好在一般的双非都会提供至少是舒心的环境。不断电不断网不停水（冷水也不收钱），不查寝室不管纪律不常查课，实验室摆满高端的硬件设备尽管连老师也不会用却也从不阻止感兴趣的学生借来私下捣鼓，学校还是提供了足够宽容的环境，充分理解各人都应有各自的独立的想法。 刚来这所无疑是令人失望的学校时我也自怨自艾，然而很多时候学历并不是仅靠我们的才智就能充分决定的事，这和地区以及家庭等一系列被称为「平台」因素息息相关。有一些彻夜难眠的夜晚你可能会觉得自己并没有比更高学历的同学们笨多少，你也未必就一定无法达成他们的技术成就（也就是说他们仍在你的「视线之内」）；而究其原因，与其说是你真的不配拥有更加光彩夺目的生命，不如说仅仅是你没有足够高的「平台」。一个人要达到卓越首先必须相信自己是卓越的（米沃什语），要成为这样的环境中的佼佼者必须向更高更远处看齐，比如完成一门公认为较有挑战的课程。 一想到我大一时也是十分痛苦就会觉得正是近些年来明白的许多道理才使我更加平静和坚定。一点双非学子的肺腑之言，与诸位共勉。 参考文献 [Ongaro 2013]: Ongaro, Diego, and John Ousterhout. “In search of an understandable consensus algorithm (extended version).” (2013). [Ongaro 2014]: Ongaro, Diego. Consensus: Bridging theory and practice. Stanford University, 2014. [Valois 1994]: Valois, John D. “Implementing lock-free queues.” Proceedings of the seventh international conference on Parallel and Distributed Computing Systems. 1994. [Hunt 2010]: Hunt, Patrick, et al. “{ZooKeeper}: Wait-free Coordination for Internet-scale Systems.” 2010 USENIX Annual Technical Conference (USENIX ATC 10). 2010. [Arora 2017]: V. Arora et al., “Leader or Majority: Why have one when you can have both? Improving Read Scalability in Raft-like consensus protocols,” in 9th USENIX Workshop on Hot Topics in Cloud Computing (HotCloud 17), Santa Clara, CA, Jul. 2017. [Online]. Available: https://www.usenix.org/conference/hotcloud17/program/presentation/arora 另请参阅特别推荐的资料以粗体标注。 https://github.com/OneSizeFitsQuorum/MIT6.824-2021 2021 MIT 6.824 札记 - https://www.inlighting.org/archives/mit-6.824-notes/ 一致性模型与共识算法 | 谭新宇 - https://zhuanlan.zhihu.com/p/463140808 线性一致性和 Raft | PingCAP - https://pingcap.com/zh/blog/linearizability-and-raft TiDB 新特性漫谈：从 Follower Read 说起 | TiDB Robot - https://zhuanlan.zhihu.com/p/78164196 Raft ReadIndex 有什么神奇之处? | 吴祖洋 - https://www.ideawu.net/blog/archives/1192.html TiKV 功能介绍 - Raft 的优化 | PingCAP - https://pingcap.com/zh/blog/optimizing-raft-in-tikv 我靠，又是一万多字，真是写死我了。","link":"/programming/deep-dive-in-6824/"},{"title":"我的大一啊，sigh","text":"那啥，本来是不大喜欢写什么“总结”之类的东西的，一来这些东西本来用处不大，写着也浪费时间；二来按什么“有多少个‘第一次’”诸如此类的分类式总结，咱记性又不怎么好，让我硬去凑这些个分类，也不怎么好玩。 可是啊，最近实在是有点太迷茫了，感觉不回望下过去，未来也不知道应该做什么；有些太累了啊，对计算机和代码、和种种__本应__坚持的事情的兴趣如果不是已经消退——希望不是——也是锐减了，或许这就是颓废吧。 所以，各位应该已经从字里行间闻出来了——这是一篇自我色彩浓重的文章，尤其是，不可避免地包含了大量自己对自己的评价和看法。当然这一年来也少不了技术，但若读者期望要从本文中获得什么知识性的见解之类，恐怕是要落空的了。 这就算是safe harbor了——若对这样色彩的文章不屑一顾的读者，想必对我这样的人，也不会有什么兴趣的；若是如此，本文自然不是为您而写的啦——毕竟这是个人博客，自我色彩浓重的文章，也没什么不应该的吧？ &nbsp;头图摄于2019年国庆期间，于广州地铁三号线地狱西。 技术前两天在群里搜一个大佬发的链接的时候偶然翻到了去年二月份在群里的发言，发现自己那个时候在群里问了一个有关Kotlin声明处变异和类型上界的问题…… 问题是挺基础的，我想我现在应该不会再问这样的东西了。不过，想到有很长一段时间都受身边人的影响强行把时间和精力都砸到了并不喜欢、并不感兴趣的方向上，感觉确实是蛮不应该的——细想了想自己学很多东西的时候很难分辨出「感兴趣，喜欢！」和「哇这个好酷好帅好高大上教练我也想学」之间的区别，很多时候做的一些事情、学的一些东西与其说是真正学到了什么，“提升”了自己什么，不如说仅仅是为了让自己在「别人的眼中」很厉害而已——但事实上却完全不是。 一年以来，我已看到真正低调的强者是什么样子。和真正的大佬比起来，我想我确实是只会被秒得体无完肤而已：面对一群拥有你极度渴望的器物和能力，达成了你始终认为高不可攀的成就，经历你自认只能永远观望的体验——这样的感受并不奇怪，我会为此开脱，这样的想法，是平凡的： 但是，这个回答却也是再正确不过了——何必呢？ 何必呢？可或许这样的一课是避不开的吧。很早以前「友人P」（这么匿名式的称呼感觉好好玩啊 (￣▽￣)”）在评论一位我们都认识的网友时说（大概是这样），他正在经历认识到自己并不天才并不全能的阶段——我大概也会这么说现在的自己吧。这样的挣扎，对于一些本就十分低调、十分「擅长反思」并对自恋心理和自我中心主义怀有警惕的人们来说想必看起来是既可笑又幼稚，但只可惜我不是那样的人：我是挺幼稚，也挺可笑的。 果然如预想中那样跑偏了——一年来我学到了什么呢？除了这样的仍「在路上」的认识，我想，或者说，我希望，自己技术上还是有所进步的——至少我，至少应该不会再问“Kotlin中什么和Java的 extends ? 对应？”这样的问题了…… 吧。 Kotlin熟练II，开了个DSL的新坑；后端踩坑无数，Exposed，Ktorm；Ktor，http4k。还有gRPC，那会儿官方的Kotlin支持还没出，社区做的kroto+是真的难用…… 不过现在的官方支持倒是没用过也没看过。 计组专精II，整了整计组，看完了《软硬接口》，正在拿SystemVerilog和Verilator写简单的MIPS CPU，到本文写作时基本完成了18条核心指令的支持、五级流水线和所有的冒险检测、旁路之类，打算再把cp0也给弄弄…（可以康康咱以前写的博客文章，希望还会继续更新……） 老实说并不如之前想的一样那么难。以前总觉得「哇，这个东西那么牛逼，我这辈子肯定都搞不定」就连真正坐下来写的时候也总想「唉，要写流水线了，这难得要死肯定不会弄」、「唉，要做旁路了，这太复杂了肯定整不出来」之类，但是写完了就有种「就这？」的感觉… 如果瞎想是一项运动，我早TM是世界冠军了。 函数式有点兴趣。看了一些乱七八糟的文章和conf，还发现了一本挺棒的Haskell书书，一千多页看了两百多了… 英文不好看的很慢，可惜也没办法；打算继续看完，期望是人生第一本读完的英文书籍… Scala专精I。总算是看完了喵呜呜很早很早很早以前送的Scala书书，被圈粉。写了一些没什么用的试验代码和一点gRPC的测试，不得不说ScalaPB比kroto+好用多了… 还看了看Dotty的强强语法，是真的强强。 过度设计专精II。写项目架了一个超大超傻的技术栈，容器化docker-compose，反代traefik，web托管Caddy，后端AdoptOpenJDK，OAuth认证中间件Hydra，业务数据库MySQL，时序数据库Graphite，可视化Grafana，容器管理Portainer，资源监测Netdata…… 感觉自己简直脑抽，希望还是学到了什么东西吧…… 总的来说就这些。还看了看Vim之类，不过用的很少，也不怎么熟… IDEA倒是用得熟练多了，新记了不少快捷键；现在对敲键盘时还要不时碰一碰鼠标这样的打扰要敏感多了。 按我这个后见之明偏误由来已久的功利主义上脑的废物的习惯，自然要问的问题就是——这些时间中，有多少花得值呢？写不写一个五级流水线CPU、知不知道什么是TLB、能不能用MIPS写递归求阶乘、了不了解操作系统如何管理内存——这些到底在多大程度上会影响未来的——尽管，我无比希望能是「现在的」——实习和工作？一个所谓科班出身，学习过这方面内容的程序员，和一个对此毫无了解的程序员，在应对千变万化、纷繁复杂的实际业务需求时，到底会有怎样的差别？ 我不知道。程序员社区里总有人讨论这些，也总有人说，这些会渗透进思维中，或者足够高要求的业务总会逼迫用上这些东西云云。但是真的如此吗？ 现在做的东西到底有意义吗？我走的路是正确的吗？ 我未来到底要做什么？我到底喜欢什么？我到底喜欢计算机、喜欢技术吗？ 唉，我也不知道。很喜欢写Web后端吗？很喜欢Vue.js糊前端吗？很喜欢做存储、基础设施吗？很喜欢大数据吗？很喜欢FPGA吗？很喜欢化学实验吗？很喜欢计算机吗？？ 如果不是，如果对任何已知的方向说到底都没有多少兴趣，那该怎么办？ 去年，或者即便是今年早些时候，我都还有想着几项不多、但对我来说相当昂贵的梦想，想着大学有闲的时候能有钱自然是再好不过；现在看来，大概只是空想而已吧…… sigh. 生活最轻松、最好讲的部分当然要放在最后面啦——不过，看到这儿还不觉得是在浪费时间的读者，应该也没有几位了吧？ 高中毕业之后的假期和网友面包包、🍋、信酱酱去上海组队打了一次hackathon（需要理解，那时候我还以为自己天下第一…），之后和前两位在上海玩了两天。 人生第一次自己在外边旅游，真的挺舒服的。很自由。（当然得有钱… 如果这钱是自己挣的就能是百分百的无忧无虑了，可惜于我而言这估计还是令人难受地遥远…） 后来国庆的时候和（几乎是唯一几位比较熟的）朋友们去了广州，也即本文头图的由来。总感觉一个城市有没有河、靠不靠海是很大的区别，希望以后自己也能在一座有河或者靠海的城市工作、生活。 今年一月份一个人去了趟深圳。老实说一个人自由多了，到处跑，两天去了好多地方。面基了腾讯大佬t桑，羡慕了一圈老干妈总部内部实用简单的精致；只可惜那时候还不认识e哥，第二天去深圳湾天气也不大好。 去的绝大部分美术馆、博物馆都是免费的，不仅免费还送纪念品，有钱的城市就是任性。市民中心底下就是深圳市政府，一整片玻璃幕墙，身体力行地告诉你什么是有钱的现代化城市。市民中心那片的公建是真的有艺术感，太富了。当时想着要在深圳工作生活，现在想想还是算了…… 旅游就是拍拍拍，自那以后就很想拥有一台富士XT-30，或者什么相机之类，不知何时才能摸到自己的截幅微单呢。 日光之下没了，这篇文章就到这。希望下一篇能回归有些用的技术主题文章吧。 不过最希望的还是，时间能为我解答这些让我完全睡不着觉、每天要翻腾两三个小时，代码也没法写、只能每天躺平浪费时间的恼人问题啊…… 不过最最希望的还是，能当下送我一个大厂的实习就好了啊。（大哭哭） 十点了，又浪费了一天。","link":"/life/freshman/"},{"title":"First Step Towards FPGA (1): SystemVerilog Quick Take &amp; Pros and Cons","text":"Every time programmable hardware programming is mentioned, Verilog or SystemVerilog comes to our mind — such fact, IMHO, is ironically contrasts with another interesting, if not consensus, but at least first impression of those hardware newbies just like me, that the fundamental software and development toolkit in hardware programming field is far from diverse, mature and easy-to-use. Comparing to software engineering, there are not too much languages, tools or methodology to let you pick and choose, even among the limited available choices, most of them are either lack some important features, or just too expensive to investigate. Undoubtedly my first step towards FPGA, looking around and pick a combination of language, simulator and testing method, is a brief journey, but it also involved too many investigation as well as unexpected disappointment, which makes this journey more difficult, and more tiring. This article is intended to outline some of my conclusion, which is what I’m using now, and what I have used but quited. For me, there is a long-lasting haunting thought — writing a CPU, and that is the beginning of the story. About half a month ago I set sailed, and till now I have finished a testing library for Verilator, and a very simple MIPSs CPU that have nothing to do with pipeline, trap, and whatnot. So conclusion comes first: I’ve done most of these in combination of SystemVerilog (language) + Verilator (simulator) + CLion (IDE) + althas (testing) + Xilinx Vivado (synthesis). I will explain the reason just below. I’ll not gonna say this is the best workflow of hardware programming, specifically FPGA programming, it still have many incompetence in terms of my requirements which I’ll talk about them later as well, but I do hope this article could help you find a workflow that just suits yourself. This article will only discuss the very first part of my workflow, namely the SystemVerilog part. Remaining techniques will be discussed in the follow-on articles of this series, so stay tuned! Verilog / SystemVerilog ?JUST DON’T ask why VHDL is not mentioned. I won’t discuss VHDL here, for one thing I know nothing about this language, and for another I think it’s somewhat considered obsolete or just not recommended in many existing articles like this one. What’s different?SystemVerilog has been described as a superset of Verilog, which is another predominant language in hardware programming field, and it certainly is. SystemVerilog have an impressive outstanding compatibility with Verilog, most synthesis environment, at least Xilinx Vivado, allows you to instantiate Verilog module in SystemVerilog module and vice versa. Many Verilog definition could be directly translated into SystemVerilog, without or with only little altered. Here is a piece of code taken from my CPU project astrio (currently it’s still in private, I’ll publish it once I finished pipelining, trap, AXI bus and implementation on Zynq SoC, all sort of things), it can help you — I assume you already knew Verilog, and understand what these assign, always means — glimpse at the vanilla-SystemVerilog, and understand what’s new there: >folded pc.svsee code on GitHub1234567891011121314151617181920212223242526272829303132333435363738import Parameters::*;import PCType::pc_cmd_t;import Types::addr_t;module PC( input PCType::pc_cmd_t cmd, input addr_t load_pc, input bit rst, input bit clk, output addr_t pc, output addr_t inc_pc); initial pc = InstStartFrom; addr_t next_pc; assign inc_pc = pc+4; always_comb begin unique case (cmd) PCType::NONE: next_pc = pc; PCType::INC: next_pc = inc_pc; PCType::INC_OFFSET: next_pc = inc_pc+load_pc; PCType::LOAD: next_pc = load_pc; default: next_pc = pc; endcase if (rst == 1) next_pc = InstStartFrom; end always_ff @(posedge clk) pc &lt;= next_pc;endmodule : PC It’s not difficult to find out that there are many differences comparing to Verilog. I’ll highlight those are most important or influential in terms of the actual programming work: typedef in SystemVerilogYou may notice that there are some addr_t stuff in the code, and even if you are just a newcomer of C, you may still notice that here we adhere to the general naming convention of a typedef, namely suffixed whatever a typedef with _t, which I think is just inherited from C’s naming conventions. So as you may assumed, SystemVerilog do have typedef. Let’s look at the definition of addr_t: types.svsee code on GitHub12345678910package Types; typedef logic unsigned [31:0] addr_t; typedef logic signed [31:0] op_t; typedef reg signed [31:0] op_reg_t; typedef logic unsigned [4:0] reg_id_t; typedef logic unsigned [31:0] inst_t; typedef reg unsigned [31:0] inst_reg_t;endpackage : Types Okay, now it’s pretty clear. Generally typedef in SystemVerilog is no different from its counterpart in C/C++. Intuition always right, just use typedef (type) (name) to define your own data type in SystemVerilog to make your code more concise and configurable. BTW, typedef is a great replacement for parameter in many cases, use it wisely, and your code will definitely looks better. But, wait, what the hell is the package? package &amp; import: Package system and separate compilationExtract the common definition of your code, wrapped them in a package or whatever is always a good idea. It improves the readability of your code, alleviate namespace conflicts, and enables the separate compilation, i.e. when the code are recompiled, only the modified part is needed to be recompiled while the common and relatively less frequently modified part can be excluded, so less files will be recompiled, therefore speed up the recompilation. SystemVerilog supports such encapsulation by providing keyword package and import: the former is for encapsulate, the latter is for import it. One thing should be noticed: if you read my codebase that linked hereinbefore, you may find that only typedef, functions and some parameters are encapsulated in package, this is because typically they are the common part of your code. I won’t encapsulate my module in package, seems to me it just don’t deserve. enum &amp; enhanced case clause: enumeration works like a charmIn the pc.sv code above, there is a input cmd typed PCType::pc_cmd_t. You may guess that this is a typedef defined in package PCType, but what the actual type is? Continual reading, the input cmd is passed into a unique case clause, perhaps it’s something akin to enumeration? And unique means that there are no overlapping between the matching conditions, so only one block will be triggered in any cases? You are right! Here’s the definition of pc_cmd_t: pc_type.svsee code on GitHub12345package PCType; typedef enum bit [1:0]{ NONE, INC, INC_OFFSET, LOAD } pc_cmd_t /* verilator public */;endpackage : PCType Here we define a enum that occupies a 2 bit wide bit, then aliased it as a pc_cmd_t, where we adhere to the appreciated naming conventions. The whole definition is encapsulated in a package named PCType as I discussed before. Still there are something weird — what is the bit? And why there is a comment /* verilator public */? I am going to talk about the bit thing right now, but for the Verilator thing, till we know what Verilator is and what can it do can we grasp at the idea, so the answer is in the follow-on articles of this series. logic &amp; bit: abundant but systematic built-in datatypeIn addition to the native datatypes directly inherited from Verilog, lots of new datatypes are described and added. Presumably the most crucial subset of these novel datatypes (I think many of them is just excessive abstraction and design and actually not so required but make the language considerably more complex. I’ll back to this point later) is logic and bit. Technically you can regard logic as wire plus reg. Datatype logic wipe out the delimited wire and reg, for synthesizer will deduce the underlying hardware (a wire or a register) automatically, using the context. But if you are declaring a tristate gate like inout, you have to use wire but not logic. Why is that? The reason is logic-typed variables can only have one driver. No surprise here, logic still have four state: 0 (low), 1 (high), X (unknown) and Z (tristate gate high-impedance), but in many cases we can firmly believe that only two state, 0 and 1, will be involved. And that’s what bit used for. It’s a apt datatype for defining enumeration. Actually there are plentiful datatypes newly added into SystemVerilog, and most of them are not mentioned here due to some reasons, and I’ll come to this later. always_XXX: enhanced always clause enable fine-grained elaboration hintMaybe the most complex, sophisticated and perplexing part of Verilog/SystemVerilog is the always clause. Without intensive study, profound understanding and very careful development, unintended latch or flipflop will be deduced with no warnings, which surely is a bad thing. SystemVerilog partially solve this problem by giving you fine-grained elaboration hint. There are three types of new enhanced always clause: always_comb: Next time you write down always @(*), try always_comb! This type of always clause family will automatically listen to all left-side wires and registers in your begin … end block, thus sensitive signal list should not be specified. Simulator and synthesizer will ensure that only combinational logic is deduced, and if not, a warning (or error?) will be thrown. You should not use delayed assignment (&lt;=) in the context as well. always_ff @(...), always_latch @(...): Take their names literally, these two clause is for sequential logic. One will hints simulator and synthesizer to deduce flip-flop, the other will deduces latch. The sensitive signal list is required, and you should specify the sensitive signals in it, exp. always_ff @(posedge clk), just like in Verilog. Silver Bullet?But still, SystemVerilog is not the silver bullet, and here are some downsides. Relatively poor ecosystemBefore you switch to SystemVerilog (which I highly recommend, as many renowned hardware workshops and companies had done so), the very first as well as the most significant thing you should deliberately consider is ecosystem. That is to say, does the synthesizer, implementation program or IDE support SystemVerilog? And if not, apparently SystemVerilog can not be a practical option. The good news is that almost every conceivable mainstream FPGA manufacture provides development environment with bundled SystemVerilog support — but the bad news is SystemVerilog is only supported in their relatively newer version of software. Take Intel and Xilinx as example, only Quartus II 11.1 and above and Vivado v2017.3 and above support SystemVerilog. So if you’re planning to program on old devices, such as a Xilinx Spartan-6, you are not able to use SystemVerilog since Vivado only supports 7 generation FPGA products (Zynq 7000 SoC, Artix-7, Kintex-7 and Virtex-7). Notice that some so-called individual manufacture, in particular Alchitry — the manufacture of the somewhat relatively reputable cheap, newcomer-friendly FPGA development board Mojo, do not provide SystemVerilog in their dedicated IDE as well. SystemVerilog is (overly?) complexAs I mentioned before, SystemVerilog is a complex HDL. But the problem is it’s not just simply complex, it’s somewhat overly and unnecessarily complex. Comparing with Verilog, actually many enhancements are reasonable, adequate and competent, but the other side is there are many features just trying to make coding in SystemVerilog as closer to coding in some high-level language, let’s say C++ and Java, as possible, and this way is just not so great. Many language features and keywords, such as datatypes int, longint, real, crappy multi-thread support, keyword automatic for recursive functions, they are not used in my day-to-day programming, but makes SystemVerilog unreasonably complex — as a HDL, whose theoretical role is just describes wires between hardware structures. I’ll say that this attempt, trying to “disguise” SystemVerilog as a high-level language will indeed improve the testing experience. (Personally speaking the TESTBENCH-based and $display-based testing methodology of Verilog is incredibly inefficient and grueling, I suppose the SystemVerilog way of doing things will be a lot easier) But, I still hold the belief that HDL should be a HDL solely, and high-level language should be a high-level language solely. It’s just redundant, and usually a bad idea to let one side covers the other side, or to “be” the other side. Given the consensus that hardware validation and testing, especially the generation of testcases should be performed in a high-level language, maybe use a high-level language to do such things will be a great idea — and Verilator is created for this. I will cover Verilator and related topics in the next article. After all, this is just a personal preference and personal perspective, and language is just a tool. If it’s too complicated, just pick out the acceptable part: and this is exactly what I’m doing. Use what I called vanilla-SystemVerilog is just stick to the principle that SystemVerilog is nothing but a HDL language, you should only use the HDL part of it, take is as a “better Verilog”, use entirely a handful of features and enhancements including what I mentioned before. Limited featuresEven if your environment fully support SystemVerilog in elaboration, synthesis and implementation, your switch may still not very pleasant as you may expected. Specifically, my Vivado v2019.2 satisfactorily supports SystemVerilog in normal develop procedure, but you can’t add your SystemVerilog modules to your Block Design directly. Overall this is not a big problem, in my case all I need is just to create a wrapper in Verilog then linked IPs to that wrapper, but your mileage may vary. It all depends.Eventually comes the golden rule of selecting things in the realm of techniques, technicians, languages and programmers — “**It all depends.**” As I said, language is nothing but a tool, how to use it and to what extent will you use it in the daily basis, is just personal predilections. Tons of tutorials and blog posts will teach you how to use SystemVerilog as a high-level language and do validation things in such way elegantly — and I bet many people are good at it. But I’m just not on their side, nor am I appreciate their methodology. Hope this article will help you get the basic difference, pros and cons of SystemVerilog, comparing with Verilog, and then decide whether to put it in your own workflow. The next passage will cover another facet of my workflow — Verilator, it lets you simulate and validate your DUT in C++/System C, which is a lot better then do such things in HDL, personally speaking.","link":"/hardware/fpga-journey-1/"},{"title":"咱的新博客","text":"一直打算自己写博客的一套前端和后端，前端本来已经写了挺多的了，现在看来是要搁置很长一段时间了… 感觉折腾这些毕竟没啥用，还是要花时间写文章才行。。 可文章也太难写啦QAQ，每次都感觉开坑写了两行就不想动了，总感觉有些东西不能说得有些见地就不如干脆不动笔以避免「灌水」之嫌。总之以前的文章大概是不会发上来了（因为太黑历史了）这个博客大概会放些近期自己写的东西，科幻评论啊，以及稍微长一些、图文并茂的、不适合放在咱Telegram Channel（左侧有链接）的一些玩意，向e哥和冰冰两位大佬看齐QAQ 就是这样。总感觉现在这个新主题有点太冷淡了些，以后再慢慢调吧……","link":"/notice/hello-world/"},{"title":"我与科幻的故事，以及不情愿地2021","text":"Update 2021.1.10： 本文主要内容是一篇旧文，以及一些有关2021的文字。 最终还是打算把文章贴到博客上来（其实是一直忘了），做了一些修改，补了一些最近的我与科幻的故事。顺便这篇短文的一个选段居然还真在SFW2005的《回声》专栏上刊出来了…… 然而选的是现在看来比较尴尬的一个段落，感觉是真的羞耻（（（ 以下内容（直至文末的分割线）作于2020年2月份，经少量修订。文末有关2021的内容作于今日。 这篇文章，是我昨天晚上读完一直没读的2019年11月刊《科幻世界》中迈克·雷斯尼克先生的作品《冬至》后，熬夜到两点多写完的：纯为给自己一个交待，作为一位“半吊子幻迷”，科幻如何伴我同行六年，如何见证我通过中考、高考，从一个瘦弱、人缘很差、常受人欺负、好动又中二的初中生，“成长”——如果有的话——为一个热爱计算机、科幻和爵士鼓，正在不断敲击着一台Surface以捕捉脑海中飞絮般不断飘散的思想的化工专业大学生，同时也表达了我一些一直以来的体会，或者说是困惑。我要感谢我初中的“图书馆”、高中图书馆、镇图书馆和《科幻世界》，他们引领我，也构成了我走上科幻这条人迹罕至的道路初期的全部；我也要感谢我的父母，即便我中考和高考都是彻彻底底的失败——这不是科幻的错——他们也一直以他们的方式默默支持我。没有这些人，没有这些满溢书香的图书借阅室，我绝不会认为科幻是我一定要一直喜爱的东西。 以下是全文。本文成功刷新了我单篇文章的字数记录。冲动之下，我将这篇文章发给了SFW编辑部——老实说，不知为何，有一些后悔。 刚读完迈克·雷斯尼克先生的老作品《冬至》，因为是刊在去年《科幻世界》上的，作品末尾还附上了艾珂（刚才得知，负责过我最喜欢的科幻小说之一，《闪耀》的编辑刘维佳老师已经离开了《科幻世界》编辑部）编辑的编后记，其中宣传杂志社的义卖活动以支持这位身患重病的老作家。《冬至》是典型的历史奇幻小说——个人认为在国外明显地比国内流行——讲述了大魔法师梅林对衰老，对于这位来自未来的时空逆旅者，这意味着他会逐渐“忘记”未来，变成一个一无所知、仅仅拥有过去的“年轻梅林”，的充满无力感的恐惧。作者在这部获得1992年雨果奖提名的作品中，以一贯具体入微、细致流畅的笔调，重点突出了这位魔法师对于这种失去，这种对于“永恒之物”的忘却的冰冷绝望，犹如“渐冻人”般眼睁睁地、痛苦万分却又无能为力地被时间击倒，不断徒劳挣扎却只能缴械投降的悲痛。然而最为不幸的是，这一切竟成谶语——迈克的这个故事发表二十八年后，它的作者，迈克·雷斯尼克先生，因病逝世：这使得《冬至》最后几段痛苦、声嘶力竭的呐喊，编后记中对于老先生身体转好、正创作新作品的叙述，都蒙上了一种沉重而又模糊的悼念意味。 事实上这已经是一个月前的新闻了——所以显然，这只是一个用作引子的联想。以下才是正题：我买的第一本科幻书籍，就是迈克·雷斯尼克和姚海军先生合作主编的《世界科幻杰作选》，大概也是在恳求家长许久之后才得以实现的愿望，想来也差不多有6年了。最初发现《科幻世界》，大概是在初中的图书馆。说是图书“馆”，其实却有些名不副实：那时候的初中还是——当然，可能现在也是，毕业后再也没回去过，对此我极其愧疚——个“小破校”，远不如今日受就横卧在隔壁的镇政府的重视，最简单体会的结果，便是没钱。那时候学校的图书“馆”只是个二层的小平房，正门平日不开——不是“平日”似乎也没开过，只有从有时稍留一个小缝的铁拉闸侧门，才能进到这座图书馆的一楼。每周会有体育课，要先是经过显然学校引以为豪的国家三级古树南洋楹，再经过这扇侧门，才能到最讨厌的操场。我从小就体质很差，任何体育相关的活动都是我的心头痛，考试更是会要了我的命：不喜欢的体育课和这扇侧门间微妙的联系，就使得这扇侧门有种隐秘的象征意味。上课前要留意门有没有开，这样才能在跑完一千米、气喘吁吁累得要死要活走回教室的途中，溜进绿色瓷砖包裹的图书馆：跨过门边挂着写着“华人基金会捐赠”的牌匾的铁拉闸门，进到图书馆不大的一楼。一年中的大多数时候，广东灼眼的骄阳会透过楼梯转角上的窗户，在一楼楼梯墙边胡乱堆放着各类、过期没过期全堆在一起的杂志报纸上投射下斑驳的阴影。或许是由于此处本来就“人迹罕至”，从未听说有借阅制度，随便翻找一番，按照那个美好年纪美好的审美情趣稍加挑选，就这样认识了《科幻世界》。 当然，必须要承认，我不能保证以上叙述和真实的关联：写着“华人基金会捐赠”的牌匾是不是挂在侧门边上我已不大记得，但是肯定有这块牌匾；和《科幻世界》的“初见”可能也不会这么地富有情趣。但是——这样说得好像我是个已经看遍天下间各类事情的“大人”一样，抱歉，我未能找到更加谦逊的语词——六年过去，我做了很多错事。前阵子看最喜欢的作家阿尔贝·加缪的《第一人》，雅克，其实也是加缪本人，感觉颇有共鸣：当然（可怜的是，哎）我并没有那么聪明，但至少加缪说的“太好动，爱出风头导致做了不少错事”，这一点，绝对就是我。 所以这些时日来，我一直觉得要是真有什么我不后悔，也一直没有放下（算是吧）的事情，就是科幻。初中大概是我看科幻最“猛”的一段时期，各种各样的作品都看过一些：被英语老师没收——至今还没还我！毕业前夕我可是盼了好久：大概老师也忘了——的《艾达》；长久以来一直喜欢、并长久以来一直热望其推销词中“被买下电影改编权”能彻底落实的《时砂之王》；基本没看懂因而现在也不怎么记得的短篇小说集《微宇宙的上帝》；因而知道了海因莱茵、至今仍记忆犹新的《严厉的月亮》；去镇图书馆翻杂志时“偶遇”，极其喜爱以致请图书馆管理员帮忙找出所有库存，一本一本看完，兴奋劲儿还没过就被迎面撞来的“停刊通知”砸得有些难过的杂志《新科幻》；当时读完感觉惊为天人发誓一定要在那个买书还有种郑重感的时日里读完全系列但又抛诸脑后，近日整理书架才发觉的《太阳潜入者》；还有人生第一部在网上读完的文学作品《三体》（没想到吧）。虽然科幻目前为止陪伴我的时光还不算长，迄今为止这篇文章也是仅仅是我第个位数篇有关科幻的东西，但已经足够让这个好动、莽撞、爱出风头又“中二”的我觉得，科幻，是一定要一直喜爱的东西。 你可能会感觉这篇文章就快要结束了，然而它并没有——是的，科幻，大概是唯二我能说是一直没有放弃的东西中的一件（另一件是爵士鼓）。在这里应当加一个“注”，那就是（可怜的是，哎）这唯二的两件事，我都做得不怎么样。拿科幻来说，我从来不敢称自己为“幻迷”，因为相比真正的幻迷们我确实还不够，而最多只能是“半吊子幻迷”：相比我看过的《科幻世界》，我真正能留在手边的——是“订”的而不是“借”的——实在是很少。一直以来，我都觉得相当遗憾，因为很多优秀的作品要再想找到，只空有标题和作者，显然会难办许多；而更令我遗憾的事情，那就是我直到2018年，才觉得应该要把看过的好作品，至少要把标题和作者记下来：这导致我忘记了不计其数的优秀作品。这些令我觉得自己因而只能算是个“半吊子幻迷”的故事或许能让各位读者更加理解我对于科幻的复杂感受。那么，如果要说我这个“半吊子幻迷”，对科幻，能有什么切实的体会，那就是，科幻，是个真正孤独的爱好。 是这样的。（应该也，或者说希望会有一些幻迷能和我这个“半吊子幻迷”有一些共鸣吧）在《科幻世界》的“我与《科幻世界》特别征文”专栏里，看过不少幻迷讲述自己认识科幻的故事，感觉他们中不少都能在现实生活中遇到比较喜欢、也能畅通地交流科幻的人。照我说，这不能不说是一种幸运：因为我就从未遇到过。不仅是在现实，就是在网上我不大的圈子（或许这就是原因）里，也从未听起人提到过四个字，《科幻世界》。初中时还觉得没什么，那个时候的我对科幻作品应该还没有什么具体的想法或思考，但到了高中，这种情况就有些难受了——经常麻烦了我那些同学们，要礼貌地听完表达欲强但又不怎么精通表达的我，大谈特谈自己刚在晚修偷着读完的科幻小说是多么地激情洋溢，多么地启迪人心。进入大学，这种情况也没有什么改观：原本还列在社团列表里的科幻社团，一问才知，早已撤销。 所以，在没有同学能够打扰的时候，就只剩我自己了：我养成了一个很不好的习惯，那就是“打脑仗”：深刻地、反复地自言自语。因为懒、也没有能力去动笔写东西，长久以来我就这样排遣脑海中无穷无尽的怪异想法。当然，也有罕见的例外，能够成功安利不多的几位同学去读某篇我大力鼓吹的科幻小说，并且其中的一两位还能对我的吹捧表示某种程度上感同身受的体认；印象最为深刻的例子便是周华杰的《时间徒刑》 ，这部作品少见地在同学间掀起了一阵来也快去也快的热潮，也能听到了不少夸赞之声。这一事件，再结合同学此前跟我谈到啃《三体》没能啃动只得弃书的故事，导致了我一种可能有些错误的印象：这一类的科幻作品，要比更“硬”一些的，更方便“安利”。然而这部我给了五星力挺的作品在其他评论中也就是个三星左右的评级，或许我该反思一下自己不怎么深刻的思想和有点儿怪异的审美吧…… 就这样，我就靠着图书馆借的《科幻世界》，还有过年和生日（大概隔半个月，这意味着钱包能短暂地稍微鼓些）精挑细选的科幻书，磕磕绊绊地，带着希冀亦有恐惧，来到了21世纪的第三个十年。我也算是见证了《科幻世界》的几次改版，加了前插，加了「回声」专栏，加了底下的小字「幻迷发言」之类；如今不用再借了，我订上了《科幻世界》，先是译文版，再是标准版（我得说我也不知道该怎么叫这个“版”），再到打算下次续订时两种都订，我始终如一地感谢科幻带给我的一切，不管这种爱好于我是否“孤独”，我想，这个丰富多彩、广阔无边、生机勃勃、充满无限可能令人无限遐想的世界，这个科幻世界和这个《科幻世界》，是我一定要一直喜爱的。 最后，热切盼望成都能成功申办2023年Worldcon。更加盼望的是，在2023年的八月中旬，我也能造访这个憧憬已久的城市，手持入场券，人生第一次，满怀喜悦和激动，踏入纯正科幻盛会的会厅。 看着自己一年前写的这段文字，突然感觉十分怀念。 已经记不清楚写下这篇文章时的场景和动机了——只能从时间上推断，大概那会儿确实是在家里无所事事，捣鼓科幻和科幻评论的状态。 一年过去，很多事情都永远改变了。和一些人就此作别；认识了新的朋友；组了乐队，上了学校的音乐节；学了一些新东西，可能放弃了更多的东西。比如，自这篇文章完成以来，我已经很久很久没有阅读任何有关科幻的文字了——尽管阿缺和张冉的短篇集就在手边。 比如，从前每天都陪着我的《夏目友人帐》，上次随便点开了一集，却最终也没能看下去；比如以前总爱在网络上和几乎从来是固定的一批网友闲聊；比如已经很久没有看到过卖弱的言辞，甚至已经忘记了当时看到这些话会有什么感受；比如一向不爱看电视剧的我如今每天都必看《老友记》，并由衷地为角色们的遭遇而愤怒、感动；比如如今打字再也不用空格做分隔符，而是会认认真真地把每一个标点都加上；比如似乎更加孤独，因为没有了曾经习惯并视之理所应当、分享各种事情讨论各种问题的一群人们。 回想一年前自己处于怎样的生活状态、又以怎样的心态度日，已经完全是一片模糊。自己那些伤害他人更伤害自己的缺陷有改进吗？与一些始终无法忘怀、永远萦绕心头、时不时使我彻夜难眠——正如以前一样——的要命的想法和念头的抗争，有任何成效吗？和一年前相比，我有更坚定吗？我有更坚强吗？我有更幸福吗？ 我不知道。 但是，我真的很想把这一年再过一遍。如果那样，或者说，如果能让现在的我处在一年前的位置，我或许会多做一些努力，我或许会多抗争一些。 我真的很不想就这样2021。 &lt;全文完&gt;","link":"/life/me-and-scifi-and-2021/"},{"title":"作为现代音乐支柱的爵士鼓（架子鼓）(1)：总论","text":"动笔写这篇文章的时候，在两个（其实差不太多）的主标题之间犹豫了很久： 爵士鼓（架子鼓）全面综论 和 作为现代音乐支柱之一的爵士鼓（架子鼓） 纠结半天，最后觉得还是后一个标题更好：不仅仅是看起来更富有文学气息，同样也更突出重点：这一系列文章（如果我能不咕咕咕的话…）将围绕爵士鼓作为「现代音乐不可或缺的一部分」，特别地，是作为节奏型乐器，在现代音乐舞台上和其它乐器的显著差异组织和说明的。 为什么要写这篇文章呢？大概主要的动机是很早以前看到的一张梗图： 想来自己也无疑如此——一旦有人，无论是谁，即使只是不经意间，即便只是随口一说，提到有关爵士鼓、欧洲文学、科幻文学、（一些领域的）编程、jrock/jpop/ACG、英伦摇滚的事情，我肯定要说个没完没了了——而且多半会说得太多，弄得仅仅只是随口一提的无辜的可怜人不得不听我飞快、激情，兴许还两眼发光地讲个没完，无疑十分尴尬。可惜咱的爱好大概算是比较小众，这样的机会也少——即便有，强迫另一个人听我唠叨个不停，也未必就是什么愉快的体验。既然如此，把这些东西写下来，放个人博客里（应该还是相当相当少见的吧？谈论爵士鼓的个人博文… 我似乎就从来没见过🤔），既不麻烦人，也可一举满足我几乎无穷无尽的表达欲和「安利欲」，想写多长写多长：一举两得，岂不美哉？ 于是就有了这篇文章：感兴趣的话题、热爱的事物，写起来想必是相当轻松的。本文主要是作为一位垃圾鼓手，以及jpop/jrock/ACG/brit rock/post rock爱好者的视角写成。部分术语、讨论尤其是历史性内容主要基于个人认识和经验，若有异见和补充，欢迎在评论区指出。 最后需要感谢我的——掰掰手指头，一共是——四位教师。身处一个并不发达的小城市，教师们也常去别处发展，这无疑是一件令人遗憾的事情；鼓手魏士朝（他的知乎；他的B站）是我第一位在网上认识的鼓手，与他的交流相当地「补完」了我对硬件的认识，尤其是收音录音相关的知识；（可能是大陆唯一的）鼓手自媒体鼓左言右质量卓越的评测和分享，是信息闭塞的时代背景下大陆打击乐资讯的重要媒介。 如前所述，本文——若无意外，若不又又又又咕咕咕咕咕咕咕咕咕——是一系列文章中的第一篇。除了「总论」，还会有「硬件」以及“软件”，如自学、练习的经验之谈云云，也会在以后的文章中涉及。 以下就是正文内容啦。抱歉，废话有些多，希望各位能学到些什么；也算是给我国贫瘠地令人震惊令人心疼的打击乐和摇滚乐做一点微不足道的贡献… 以下内容，尤其是历史相关的内容将会必不可少地涉及一些专业名词，但并不影响阅读和主旨大意，略过即可。对这些名词的解释说明将是后续文章的主要内容。 &nbsp;Photo by &nbsp; Gabriel Barletta &nbsp; on &nbsp; Unsplash. 爵士鼓（架子鼓）现代意义上的爵士鼓（架子鼓，drum kit）——顾名思义，最初起源于爵士乐这一几乎是现代音乐鼻祖的音乐形式。在如今复杂纷繁的鼓组组合诞生之前，在军乐队及管弦乐中常见的脚鼓、三角铁、镲片等，通常由不同的乐手演奏。到19世纪中叶，出于节省预算、提高「四肢利用率」等各种各样的原因，以及“双重击鼓”（double-drumming）技巧的发明和流行，各类用途、各式音色的立式鼓被制作出来并形成组合，由更少的乐手演奏。如今交响乐团中常规化的“定音鼓”，或可看作现代爵士鼓的雏形。 如图所示，这样的组合最为明显的特点，即是没有踏板（pedal）。现代爵士鼓右手一只鼓棒，左手一只鼓棒，右脚底鼓（地鼓，大鼓；bass drum）踏板，左脚踩镲（Hi-Hat）踏板，可能还要带上底鼓双踩左踏板的“四肢占得满满当当”的配置，则要等到20世纪后：1909年，以其创始人命名的历史悠久的美国打击乐品牌Ludwig——该品牌的军鼓即便其响弦调节器（snare strainer，曾听到有大佬将这玩意戏称为“扳机”，xswl🤣🤣🤣）的难用程度臭名昭著，产品音色依然享有世界声誉——生产并发行了世界上第一款底鼓踏板系统，为现代爵士鼓的出现铺平了道路。到第一次世界大战时，由于现代音乐的变革、「乐队」，而非「乐团」形式军乐队的兴起和爵士乐广泛深刻的流行，使得现代意义上的爵士鼓出现在舞台上，并逐渐成为现代音乐中不可或缺的支柱。 爵士鼓作为现代音乐支柱爵士鼓圈，流行一个经久不衰的笑话： 在乐队中跟鼓手发生冲突一般的结果只有两种，自己走人或者乐队解散。 还有另一个： 假设乐队没有主唱，可以玩后摇 假设乐队没有吉他，还有键盘 假设乐队没有键盘，还有吉他 假设乐队没有贝斯，根本无所谓 假设乐队没有鼓，那就不是乐队了，只能算个组合。 没有鼓手的乐队不能叫乐队。 又黑我贝斯。 虽说是个笑话，且无疑有严重的鼓手们乐此不疲地“自吹自擂”，“学什么乐器，就说什么乐器最难学”、“自己往自己脸上贴金”的嫌疑，可在某种程度上，这些也确实是事实。重点是，爵士鼓在现代音乐中的重要程度、支柱地位，与大众对爵士鼓缺乏了解和认识，是极其不成比例的。这一现象在国内尤其明显：从线下教学到硬件销售令人瞠目结舌的严重落后，不仅使大陆打击乐生态乏善可陈，更使得国内摇滚乐发展举步维艰。 爵士鼓在现代音乐中的支柱地位，与其作为常见的乐队配置中唯一的节奏乐器这一既成事实，是密不可分的。常见的五人组乐队，主唱，电吉他，电贝司，键盘，爵士鼓，无疑仅有爵士鼓完全缺乏“音调”这一表现维度，成为唯一的节奏乐器。在大量的乐曲演奏中，鼓手的首要职责即是保持乐曲速度的恒定和节奏的平稳，这对鼓手而言既是要求，亦是责任。对应于此，不少流行乐（常见于英伦摇滚（British rock music）），如Coldplay（酷玩）乐队、以及我最喜欢的乐队The Coronas，作品的爵士鼓节奏缓慢、单一、重复，起到的作用几乎仅仅是作为”节拍器“，为乐队中其它乐器提供重要基本的律动参考。 我曾看到一则评论，说一个月内就能教会完全零基础的初学者所有酷玩的歌曲——我大概也认同这则评论，这对大陆爵士鼓、以及各大酷玩乐队的爱好者们来说或许都是个好消息，哈哈~😉😉 但是，现代音乐中对于爵士鼓功能的低要求、浅认识，引起不少注重技术和「脉冲」（pulse）的鼓手的不满。不仅是鼓手——在编排乐曲时，各乐手常被告诫、也必须谨记在心的原则，就是 “要给主唱留空间”：鼓手所代表的「节奏」，和电吉他、电贝司、键盘等所代表的「伴奏旋律」，与主唱所代表的「主要旋律」之间的冲突，成为推动20世纪下半叶现代音乐变革的重要因素。 20世纪60年代，摇滚乐、金属乐的蓬勃发展促成了重型乐的广泛流行。在伴奏和主唱间难分难解的拉锯战中，摇滚乐、金属乐促成的音乐的重型化，无疑是一次重要的尝试。这一尝试的主旨和基调，那就是——大家都猛些。电吉他开始大量运用高度失真效果器（distortion）和高度过载效果器（overdrive）；主唱声音强有力，且经常大段使用对不少人（比如我）而言难以接受的嘶吼唱法（黑嗓、死嗓等），爵士鼓则将歌曲的速度提升到难以置信的新水平，动辄200bpm甚至250bpm的手上单击、脚上双踩，无疑是对鼓手激素水平、身体素质、听力保护措施以及演奏能力的前所未有的考验。 有没有其它的路线？这是重型乐方兴未艾之时，大家都在思考的重要课题。除了大家都猛踩油门加速加速加速加速，还有没有其它办法？这样的探寻又一次推动了现代音乐的革新。20世纪末，仍有争议的后摇滚（简称后摇，post-rock）的出现无疑是富有探索精神的音乐人们在这场拉锯战中又一次做出的新尝试：干掉主唱。完全摒弃人声的后摇滚强调律动和器乐，追求丰富、多乐器、多层次的旋律和颗粒感强、脉冲感强、层次分明的节奏，不需考虑人声的前提为该风格的乐手提供了更加自由的编曲空间，创造出的旋律递进感强，令人沉浸其中，不仅俘获了大批大批视旋律为第一要素的听众（比如我），更对其他的乐曲风格产生了不可估量的重要影响。 在现代音乐的发展时间轴上，爵士鼓始终在场，从未缺席，也不可能缺席。每一次乐曲的新变革都意味着爵士鼓的新「玩法」、对鼓手的新考验。作为或许硬件复杂度和硬件灵活度在所有常见乐器中最高的乐器，现代音乐的不断演变促使人们不断为爵士鼓发明新的技巧、工艺和配套硬件，也许这正是爵士鼓相关的硬件繁多冗杂地简直离谱的原因。 爵士鼓作为节奏乐器爵士鼓（架子鼓）在现代音乐中的支柱地位，与其作为节奏乐器这一本质同样分不开。音调这一听觉维度的完全剥离，意味着如今在各类其它乐器中占比相当的所谓乐理，相较而言，在爵士鼓的教学和演奏中，通常占不到多少分量。以下是当今世界上最为权威的爵士鼓演奏认证机构Rockschool的最高级别认证（8级）中对爵士鼓“技巧练习”部分的要求： 明显的是，除了大量——有一些我也还不知道是啥，看来我要是直接去考RSL估计是要挂的了——描述节奏型（即所谓rudiment）的术语之外，常见于乐理论著中的各类术语，如音阶、调式、和弦、琶音，并未出现在当代最为权威的爵士鼓认证的认证说明文本中。与此对应，同样由该机构编撰的电吉他（electric guitar）认证手册中，则充斥着大量与乐理密不可分的叙述和专业名词： “音阶”、“调式”、“琶音”、“和弦”，这样的文本对一位鼓手而言无疑恍若天书。值得注意的是，该机构编撰的木吉他（acoustic guitar）和流行键盘（keyboard）中同样包含大量极为相似的术语和考试环节，这是乐理知识在其它乐器中渗透广泛，且相互关联的明证。 顺带一提，几乎人尽皆知的通常意义上的所谓英皇（英国皇家音乐学院联合委员会，ABRSM） 并不提供，亦并不负责包括爵士鼓在内的现代音乐乐器的级别认证。通常而言英皇是在古典音乐，或至少是古典音乐乐器领域内享有世界声誉的级别认证机构——现代音乐乐器与其古典“对应”之间，如电吉他对原生吉他，流行键盘对钢琴，通常差异极大，演奏技巧、级别认证形式很难，也不会保持一致。大家在爵士鼓语境下常提到的所谓“英皇”，不过是对另一家总部同样位于英国、同样顶尖权威的现代音乐乐器级别认证机构Rockschool（RockSchool Limited, RSL）的错认。该机构为现代音乐乐器，如电吉他、电贝司、爵士鼓、流行键盘和一些相关领域，如音乐制作（music production）、声乐（vocal）等提供世界级、权威的级别认证。RSL与ABRSM无任何隶属或合作关系，是两家完全分离、独立的认证机构。 再顺带一提，爵士鼓领域两家顶尖的认证机构除了Rockschool，另外一家则是伦敦圣三一学院（Trinity College London，TCL）。这两家机构编排并录制的级别认证曲目及其demo技巧性强，风格意识明显，是当代鼓手精进之路上少有的质量优异的练习材料。 要在单一的节奏维度上表现风格、表达情感，这对每一位鼓手而言都是挑战。节奏如何表现风格？节奏如何表达情感？自现代意义上的爵士鼓出现以来，人们一直在思考。个人认为（以下均为个人看法和认识，若有补充或疑问，欢迎在评论区指出），其关键在于如何编排节奏，或者说如何控制节奏的疏密程度，来为乐曲提供节奏层次上必不可少的「脉冲」（pulse）——这个在上文多次提到但又为做解释的词终于又出现了。 乐曲要进行，必须有一波波向前涌动的冲力。考虑一个简单的节奏： 试听： var ap = new APlayer({ element: document.getElementById(\"aplayer-sWCXDmKV\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Demo Drum Pattern 01\", author: \"Ray Eldath\", url: \"drum_pattern_01.mp3\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 这就是大家耳熟能详的“动次打次”——问题在于，这样的节奏在乐曲中多见吗？并不。事实上，这样的节奏在乐曲中几乎是不可能见到的：因为这样的节奏缺少脉冲。一下底鼓，一下踩镲，一下军鼓，一下踩镲，线性、均匀、毫无变化，毫无起伏。乐曲在这样和机械节拍器几乎别无二致的节奏中无法进行。乐曲需要脉冲，而如何创造这种脉冲则是爵士鼓演奏中风格差异的主要体现。再听一段demo： 试听： var ap = new APlayer({ element: document.getElementById(\"aplayer-XKKhcNfU\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Demo Drum Pattern 02\", author: \"Ray Eldath\", url: \"drum_pattern_02.mp3\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 这段demo虽风格特征仍不够明显（除了显然的half-time节奏型以及一丝丝若隐若现的R&amp;B味儿），但无疑已比上边那段好上了不少。重点在于这段demo是有起伏的，有脉冲的——从谱中和试听中我们或许可以隐约意会到这种脉冲的营造方式：分布不均匀的音符，时值变化的音符带来速度的脉冲；节奏镲（Ride）在击打镲帽和击打表面间的切分演奏带来“叮，(叮)叮，(叮)叮，叮”的律动感；基本节奏型之外，每四小节出现的加花（fill）通过急促的三连音过嗵鼓（筒鼓，Tom-tom drum）提示律动的切换和乐曲的转折。 如前所述，不同风格的乐曲有营造脉冲的不同方式。爵士乐（Jazz）通过军鼓边击（Rim-shot）、正常击和轻击间的音色区别来营造起伏的跳跃感： 试听： var ap = new APlayer({ element: document.getElementById(\"aplayer-fFfZdsNh\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Demo Drum Pattern 03\", author: \"Ray Eldath\", url: \"drum_pattern_03.mp3\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 放克乐（Funk）尤其喜欢在每一小节的第三拍添加（简单的乐曲是）前八后十六或（较难的乐曲则是）shuffle： 试听： var ap = new APlayer({ element: document.getElementById(\"aplayer-vVyALtcm\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Demo Drum Pattern 04\", author: \"Ray Eldath\", url: \"drum_pattern_04.mp3\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 如前所述，快得离谱、脚发麻手抽筋、两脚当双手使的离谱玩法创造的密集、紧张的鼓点，是如金属乐（重金属摇滚，Metal）一类的重型乐的典型特征： 试听： var ap = new APlayer({ element: document.getElementById(\"aplayer-OKQXVLGC\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Demo Drum Pattern 05\", author: \"Ray Eldath\", url: \"drum_pattern_05.mp3\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 相信各位已经明白我要说什么了：作为节奏乐器的爵士鼓，除了重要基本的“节拍器”功用之外，通过纷繁的外围硬件和多样的演奏技巧为乐曲提供脉冲，同样是爵士鼓的重要意义。不同风格的乐曲在声乐和器乐间选择了不同的平衡点，这也要求爵士鼓依据风格的不同，既要变化脉冲的强度，又要变化脉冲的表达形式。军鼓技巧、节奏镲技巧，以及各式外围硬件（如反镲（china——关于这玩意为啥叫「china」又是一则故事）、水镲（splash），牛铃（cowbell）、鼓刷（brush））为爵士鼓演奏增添的新的变量，持续推动乐曲风格的多样化和演奏本身的不断演进。 最后是几首来自RSL和TCL的练习曲demo；均为风格演奏，其中一些为专门谱曲，另一些为现有曲子的翻奏，但特别突出了器乐。通过这几首节奏明显的风格演奏demo，或许不同风格的律动感能够更加明显。 注意音频文件较大，一些网络环境下需要耐心等待加载。 Lead Sheet - 摇滚（Rock）： var ap = new APlayer({ element: document.getElementById(\"aplayer-pGyyUfeO\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Lead Sheet\", author: \"RSL\", url: \"Lead_Sheet.mp3\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 大量出现了正拍的底鼓敲击、军鼓边击，密集的过嗵鼓加花和独段的军鼓solo；build-up段落亦有长段的密集军鼓敲击、重音移位敲击和长滚奏（long roll）。 Crazy In Love - 节奏布鲁斯（R&amp;B） var ap = new APlayer({ element: document.getElementById(\"aplayer-qCYgEVUh\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Crazy In Love\", author: \"TCL\", url: \"Crazy_In_Love.mp3\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); Freightshaker - 蓝调（Blues） var ap = new APlayer({ element: document.getElementById(\"aplayer-xviDeyqi\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Freightshaker\", author: \"RSL\", url: \"Freightshaker.mp3\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 急促但又极短、 几乎每拍都有 一下的踩镲 “(嚓)嚓” 声和节奏镲 “(叮)叮”声推动着整首乐曲，并在各段落间通过长过嗵鼓和滚奏衔接。 Full English Breckerfest - 放克（Funk） var ap = new APlayer({ element: document.getElementById(\"aplayer-TYijvxNj\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Full English Breckerfest\", author: \"RSL\", url: \"Full_English_Breckerfest.mp3\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 注意主歌（Verse）段落每小节第三拍必定出现的开镲（open hi-hat）和切分音。 爵士鼓作为相当昂贵的乐器鼓手的培养成本在大陆是相当高昂的。这也是大陆鼓手稀少、重型乐不发达的重要原因。 大陆的打击乐生态是相当差的。极少数城市的琴行有面向销售的实体真鼓或电子鼓，如英国 Drum Center of Portsmouth 一类，提供数百款鼓棒、上百套鼓组（drum kit）、上百种军鼓、数十种脚踏和数千款 镲片（Cymbal） 的打击乐中心，在国内，即便是一线城市，可能连一家都没有。大量鼓手购买硬件时不经思考，仅靠教师推荐或道听途说，购买价格高昂又实用性低的成套镲片—— 老板，给我直接来一套大K！钱我有的是！ ——丝毫不考虑镲片的高度客制化性质，纯图方便，导致大陆市场长期被大量老旧的套镲型号占据，高端型号（如Instanbul Mantra, Istanbul Anniversary, PAISTE Signature）不在国内流通；一些较为罕见的尺寸（如25+寸节奏镲）和厚度（如Extra Thin）在国内根本无法买到，需要花高价在 Amazon 上海淘或去日本购买。 一系列因素导致大陆的打击乐硬件成本高昂。除开极差的生态，乐器行业本身的高利润率也是其一——一些型号的镲片、套鼓，所谓的渠道价（“发价”）甚至仅为流通价格的一半。对于爵士鼓这样的大型乐器、极高音量乐器，首先，在房价无上限的城区，光有个能放置一套爵士鼓的房间就意味着不可小觑的经济实力…… 除此以外，需要相当完备的隔音、减震、吸音措施才能不招致邻居的反复投诉：在常规密集规划的高层居民楼，装修出一间不打扰邻居的鼓房几乎是不可能的事情。 爵士鼓教材稀缺，世界范围内都是如此。面向自学编纂的爵士鼓教材更是闻所未闻——绝大多数教材仅覆盖某一演奏方面或某一特定的乐曲风格，无法作自学材料使用。大陆相关教材译本发行量相当少，导致原版价格高昂，影印版泛滥。绝大多数鼓手都是跟或专业或业余的打击乐教师学习，这意味着不菲的学费。 系统地学习爵士鼓需要毅力和高昂的时间成本。失去音高的爵士鼓的基本功练习极其枯燥，进步缓慢，远不是吉他“爬格子”之枯燥程度所能比较的；大量练习仅是跟着节拍器的单纯敲击，此类纯为速度的肌肉锻炼，需要耗费大量时间，且肌肉疲劳带来的拉伤和酸痛难以忍受。 一些爵士鼓演奏技巧有一定的危险性。真鼓的练习一定要有听力保护措施（便宜的3M耳塞或入耳式耳机均可），否则将造成听觉敏感度的显著降低（但不致听力障碍——希望如此）。一些技巧，如换手捏镲、手动制音、边击、交叉手过嗵鼓、交叉手扇镲等，可能刮伤或蹭伤手指：练习或彩排时由于激素水平过高受伤事后许久才发觉是家常便饭。几年前我曾经有一次彩排时用力过猛，右手中指第二指节直接刮掉一块肉，下台后经同学提醒才发现鼓棒上都沾了血，到现在那块地方的皮肤还是凸起来一块，而且很粗糙…… 爵士鼓录音不便。真鼓音量高，频率广，一般的收音设备（手机，平板电脑等）无法处理如此高音量、广频率的信号，收音效果很差。鼓手为保护听力和录音常配有完备的鼓麦、调音台和监听耳机，这既是一笔不菲的开销，又是相当麻烦的事情——7鼓组鼓麦需要七条独立的线缆，需要大量时间和耐心架设并调试相关设备。舞台上，由于环境不可预料、吸音或混响配置不佳还可能出现回声明显、音响啸叫等各种问题。 爵士鼓沉重。中低端往上的鼓组均为钢制结构，一些支架可重达五千克，钢腔军鼓同样重达数千克；演奏需要的镲片（通常必要四组共五张，视演艺效果所需可能还需若干张效果镲、反镲、副节奏镲等）总重量可重达数十千克，以致需要拉杆式的镲片车才能搬运。我自己搬一套鼓估计是肯定不行的……😥😥 除此以外，与爵士鼓有关硬件的介绍和练习等技巧的经验分享将会在后续咕咕咕咕咕咕咕咕咕咕咕咕中一一说明。 就这些了本文就这么多，总的来说已经相当长了，近7000字，无疑又一次刷新了我的单篇文章字数记录。两天肝出来这么巨长的一堆东西，果然爱好才是第一驱动力呢…… 对了，如果你也是鼓手的话，欢迎在评论区留下你的联系方式，或在左侧（下侧）的侧边栏中找到我的联系方式——我还有很长很长的路要走，很想认识一些前辈，结识一些朋友。 就这些了。任何讨论欢迎发在评论区，我会第一时间回复；若有其它问题（如本文中使用的一些demo的完整谱子等），请私下联系我。","link":"/music/drum-1/"},{"title":"有关媒体、社会学、阶级流动、人工智能、还原论、爱情、人类沙文主义和其它一些话题","text":"我有一个非常、非常、非常不好的习惯，那就是喜欢沉浸在深刻、反复的自言自语中，不断地与现实中并不存在的、永远忍受永远包容的倾听者对话。显然这并不实际——并没有能一直忍受我烦人聒噪的慷慨之士。危险之处在于，我自己会经常陷于这样反复的自我对话当中，导致长久持续的失眠，以及更加危险的，一种单调思想的不断反复叠加最终造成极度不理智的言行。 所以昨晚就发生了这样的事情（事实上回家以来这经常发生，令我十分绝望——奇怪的是在学校并不会这样），辗转反侧、自我对话直到四点多彻底睡不着觉，于是起来将自己乱七八糟的思绪记录一二。 这就是这篇文章的由来——事实上我认为理想的形式应该是作为“访谈”，由一位永远忍受永远包容的倾听者记录并编辑，但显然本垃圾并没有这样的社会地位和条件= =。所以，本文是以一种“访谈”，或者说是“随笔”的形式组织并行文的，你应该已经从标题中看出了本文话题的跳跃性——正是如此。 创作本文的动机是作为一种价值观输出。我可能会引用多个领域的各种文献（见文末）以期使读者对我的观念有更好的理解，但我并不了解这些领域中的任何一个，正因如此，我的观点难免片面偏颇；考虑到本文是作为一篇自我陈述而非观点论证组织和行文，关于这一点，还请读者理解。 我一直对有关社会、阶级一类的话题有强烈的兴趣。我阅读的一些著作（比如，布尔迪厄的1700页巨著《世界的苦难》）、文章和资料使我产生了一个逐渐坚定的想法，那就是我认为社会学才是真正关注人们、记录人们的人类努力，其它所有号称立志做到这点的东西，无论是机构、个人还是媒体，不仅根本做不到这点，还在不停做着与这旗号相去甚远、甚至完全相反的事情。如今我们生活在由媒体炮制出的各种事件中，可以说他们所说的就是我们的现实，然而不管是国家媒体、地区媒体还是自媒体，都有明显的价值取向，它们只说在那一个价值观下值得被注意到的事情，而即便它们终于注意到了弱势群体（通常是通过一些震惊世人的话题性悲剧事件……），它们只会以一种完全服从于自身既有价值观念的方式去叙述和报道（即所谓“深度文章”……）。这样的方式的危险性和欺骗性在于，事件的炮制方式和事件的切身经历者们通常是完全无关的——如此炮制出来的事件，常常要不是加重了在既有价值观下的刻板印象（很大程度上构成歧视），要不就是完全偏离实际（问题的现实性在于，要求实地记者在短短几天内作出好几篇长篇累牍的“深度分析文章”，完全不可能期待他们能够真正切实地访谈、分析、研究，于是只能去把一些十年、二十年前一摸一样的刻板印象照搬过来旧事重提）。万维网广泛深刻的流行应该说对这个问题有一定缓解，因为个体、弱势群体的声音能够以一种超越印刷机和电视的更加自由的方式流通（比如你正在读的这篇文章），但是大量同样因万维网的广泛深刻的流行而出现、方兴未艾的所谓自媒体们实际上并未多大程度上跳出完全服务于某一个既定价值观念的目的。BBC、WSJ、端传媒，各种媒体（无论“自”不“自”）装腔作势的自私腔调令人厌烦。不过，读点新闻、经济形势之类倒也确实不会有什么，只是在处理很多社会和政治问题时，媒体的所作所为很难让人满意。 所以，我们有这么一门学科，它和人们站在一起，研究者们有时甚至会用和生命等长的时间去切实地访谈、记录、分析这些细小的声音，那就是社会学。前阵子在推上看到有社会学者在研究同性恋中的形婚群体并诚恳地寻找受访者，我就在想，要让那些媒体（同样地，无论“自”不“自”）关注到（且不说要认认真真地访谈、分析和研究）这么这么细小、且和各种价值观念很难契合的一群弱势群体，得是要花上多少个十年才能轮到…… 关于这一点点问题居然水了这么多我是完全没有料到的，我其实很担心这篇文章到最后会巨长无比以致于被tldr，而这种体例又感觉实在不适合切成几篇文章发。再来说说社会本身。阶级和阶级流动是社会中最为重要、也最令人感兴趣的话题，关于这个，我想说一下自己的见闻和体会。 很早以前在知乎上看到过几个有关阶级流动的非常长的回答（已经退乎很久，出处亦无从考证），其中主要讲了美国著名社会学家Peter Blau创设并执行的一系列的有关社会流动的社会调查（很多内容不大记得了，只有几个关键的点我大概还能确认。我大体上跟这里和这里对照确认了一下自己的记忆，若有疏漏，还请原谅）。这一系列调查“在方法论意义上影响非常深远”，深刻影响了在那以后社会学的基本研究方法。具体来说，这项研究将通常被认为是离散的变量职业连续化了，它的方式是通过海量的问卷调查，收集社会中各个阶层、各个教育水平、各个收入级别的人们对一组职业的评分——这组海量的、连续谱式的评分经过统计学处理，就得到了每一种职业的声望。我们最关心的是在这组职业声望中较高的那些，它们被称作“高声望职业”。 Blau进而提出了一个现在看来非常显然、但仍然极有见地的观察：他说，要看一个社会是否流动，只需要观察父母职业和子女职业的相关性就可以了。社会流动系数被定义为根据父母职业预测子女职业的概率，如果这个概率是1，说明社会（阶级）是完全不流动的；反之则说明社会是完全流动的。这些观察和定义在我看来十分精妙。在这之后，Blau就在美国执行了一系列大规模、广泛的社会调查，希望得到美国的社会流动系数。具体的结果是多少我记不太清楚了，但是大概是 0.7+ 的一个数值；父母的职业居然能以远远超过一半的概率“遗传”给子女，这在我看来是十分令人震惊的事情。但是我觉得这还不是最为重要（所以才记不太清楚了嘛）的发现，最为有意思的发现是研究中途得到的两点结论： 第一点，我们想知道，父母从事高声望职业，子女也从事高声望职业的概率有多大。特别地，我们关注，父母从事高声望职业，子女也从事高声望职业的概率比一般人要高多少。我想结果可能出乎很多人意料，研究表明，如果父母从事的是高声望职业，那么子女从事高声望职业的概率要比人群中的概率高出十一倍。在我看来这个值难以相信，读文章读到这里的时候我内心的猜测是最多最多最多也就是个五六倍的影响吧，结果却是我这个五六倍上再往上翻了个倍。关于这个概率具体是多少可能也会很有意思，这个概率事实上统计学地表明了一代之内阶级滑坡发生的概率有多低，也同样表明了一代之内，仅靠个人努力能够达到的阶级提升跟家庭环境的直接作用比起来是一个多么些微的数量。 再来看第二点，事实上我个人感觉第二点还要更加有意思：我们还想知道，如果反过来看，父母不从事高声望职业，而子女从事高声望职业的概率又有多大？我想这个意思就很明确了，我们是在说一代翻身的概率，或者某种程度上即是寒门出贵子的概率。然而令人惊讶的是，研究表明这概率是…… 0。统计学上我们得到的结论是一代之内不可能翻身，或者说，对于小概率事件，我们认为它在一次试验中不可能发生。 综合来看，这项研究很好地回答了一些问题，那就是社会流动的滚雪球现实——社会流动是个长期的积累，是一个好几代人在职业声望表上一点点向上爬的漫长路线。很难有不进反退的悲哀，也罕有一步达成的奇迹。 最后再来看看这个声望表本身。同样具体的我也记不清了，在美国前三的大概有大学教授、律师还有一个别的什么；而在中国大概是大学教授、官员还有一个别的什么；看得出来官员在中国的地位明显比在美国的要高很多。另外还有一点有意思的就是，千禧年后英国好像又做了一次大规模的职业声望调查，结果和半个世纪前的结果居然没差多少。（前边提到的Blau的研究的主要成果是1967年出版的 The American Occupational Structure，《美国职业结构》） 你可能会想知道这样的观察在国内又是什么情况。我看过一些分析性（而不是实证性）的文字，大意是说在国内由于教育资源（尤其是高等教育资源）的严重不平衡再加上户口制度、官员的高声望和福利制度的缺乏，社会流动的情况大概只会更差。不过发展中国家的社会是不是一般就不如发达国家的流动呢？这其实也是一个很有意思的问题。 然而，这些研究没有回答的问题其实更加关键，那就是——为什么会这样？为什么一代翻身就这么难？为什么社会不能更加流动？如何才能让社会更加流动？怎样才能让社会有更多一代翻身的奇迹？我看到的是，或者说我的臆测是，当代科学，“精密科学”，在这一类重要的人文、以及人文交界边缘的问题上表现出令人尴尬的茫然无措。这样的问题还有：什么是成功？如何缔造幸福的人生？意识是什么？如何构造通用人工智能？认知的极限在哪里？科学能够帮助我们最终达到全知吗？爱情是什么？为什么我们会被一些人吸引、而又排斥另一些人？意识的物质基础是什么？爱情的物质基础又是什么？ 我想先说说很早读过的一篇很棒的essay，题为 Why general artificial intelligence will not be realized，作为article发表在Nature旗下的OA期刊 Humanities &amp; Social Sciences Communications 上。文章的大体思路是，通过引述大量哲学上的分析（比如维特根斯坦、Hubert Dreyfus），再配合对现实中通用人工智能令人尴尬的“进展”（IBM Watson 的失败、AlphaGo “lacks flexibility, and is not able to adapt to changes in the environment. It has even turned out to be vulnerable to tiny changes. Beacuse …, deep reinforcement learning has so far found few commercial applications. Research and development is costly, but DeepMind’s losses of 154 million dollars in 2016, 341 million in 2017, and 572 million in 2018 are hardly a sign of success.”、华盛顿大学一个非常有名的以构建哈士奇犬 - 狼分类系统来说明缺乏解释性的神经网络最后会得出多么令人啼笑皆非的结果、人工智能对话系统 Mitsuku 极其拙劣的对话水平）的描述，得出通用人工智能或不可行的结论。文章中最为有趣的一个分析在于，文章提到，这样的一种思潮、“对机器能够做到什么的严重高估，以及随之而来的对人类、自然和进化之丰功伟绩的严重低估”，是源于一种牛顿主义。牛顿物理学不可否认的极大成功完全重塑了17世纪以来的亚里士多德式的“常识物理学”，将物理学、甚至是（由于这样的物理学的极大成功）世界本身抛入了数的、理型的、计算的范畴。人们开始相信，世界的本质是计算的，世界的本质是算法的，只要我能够知道当前世界上每一个原子的状态，再套用这一个“世界算法”，我就能够预知未来的任何一刻（我第一次听到这种说法甚至是很早很早很早以前在美剧《陨落星辰》中）。将这套哲学搬到生命体中，那就是在说，意识本身也必定是算法的，意识只不过是一堆神经元的互相连接，只不过是一堆电信号在一套算法控制下的不断传导（相信这一套的人们有一个非常时髦的哲学标签，叫“取消物质主义者”）。这样的只不过随处可见——宇宙只不过是粒子的规律运动，爱情只不过是化学物质的复杂作用，意识只不过是神经元的互相连接。 关于这一点为何如此，以及后果是什么，必须要提到科学史上的不朽名篇——亚历山大·科瓦雷的《牛顿综合的意义》，这篇文章作为序言收录在商务印书馆2016年出版的《牛顿研究》中。文章中说到： 我总是说，近代科学打破了天与地的界限，把宇宙统一成了一个整体，这是正确的。然而我也说过，这样做是付出了一定代价的，即把一个我们生活、相爱并且消亡于其中的质的可感世界，替换成了一个量的、几何实体化了的世界，在这个世界里，任何一样事物都有自己的位置，唯独人失去了它。于是科学的世界——真实的世界——变得与生活世界疏离了，最终则与之完全分开，那个世界是科学所无法解释的——甚至称之为“主观”也无法将其解释过去。 的确，这两个世界每天都——甚至是越来越——被实践（Praxis）连接着，然而在理论上，它们却为一条深渊所隔断。 两个世界：这意味着两种真理。或者根本没有真理。 这就是近代思想的悲剧所在，它“解决了宇宙之谜”，却只是代之以另一个谜：近代心灵本身之谜。 这段话我非常喜欢，高中时一度能反复背诵。（就和柳鸣九先生翻译的《局外人》的最后一段一样） 我们看到的是，这样一种经常出现的只不过，是一种脱胎自牛顿物理学的核心思想——它缘起于18世纪以《原理》为代表的牛顿哲学的广泛流行，最终渗透进现代科学、进而渗透进现代生活的每一个角落——它有一个名字，叫做还原论，或者说是还原主义。（我个人粗浅且不负责任的理解，是将还原论、结构主义等这些倾向理解为同义词） 雨后为什么有清新的气味？因为产生了臭氧，而臭氧令人精神振奋。为什么撸猫会感觉很爽？因为进化使人类具有“怜幼”这一机制，而这会促进大脑中多巴胺等递质的分泌。爱情从而而来？来自苯乙胺、肾上腺素、多巴胺、血清素和催产素等一系列化学物质。 企图在一切现象上寻找物质的、粒子的、可计算的解释的这种倾向，将一个现象不断还原至更本源的层次，不到物质的、粒子的层次誓不罢休——这样的还原论如今甚嚣尘上。随便搜搜，你就能看到大堆大堆的诸如 “爱情激素”、“快乐递质” 的文章，这是牛顿主义在当代生活无情投射的表征。 这样的思潮带来的一个自然而然的想法和后果，就是人类沙文主义，或者说科学沙文主义：科学能够帮助人类达到全能全知，科学和人类最终能够解决一切问题。我对这样的想法最为深切的体会是20年年中在深圳（当晚还和e哥面基了），午后和学长散步到深圳湾，坐在广场前的台阶上吹着海风，看着温和的阳光透过清澄透亮的空气照射在波光粼粼的海面和悠闲自在地散步和骑车的人们身上，那时我忽然对学长说，如果巴黎协定没有达成，20、50年后这里将不复存在，深圳会变成一片沼泽，人类将在仅剩的高地聚居地苟延残喘。当时学长非常直截了断地打断了我，他指了指深圳湾联通大海的那个豁口，比划了一下说，我们会在那里建一座大坝，冲毁一切的海水将被挡在外边，科技会帮助我们控制内外水体的高度差，人们将继续安居乐业。 这是我第一次经历这样的观念在现实生活中的切实体现。坦白地说，我是科学的忠实信徒——我以前是《环球科学》的常年订户，如今则经常关注 Nature 自然科研 等公众号的推文。但是，对于这个问题，我有着更加人文、或者说有些矛盾的观点：我不认为还原论能够一直帮助人类，我不认为科学能够最终达到全知的境界，我不认为科学+人类=上帝，我不认为我们最终能够靠科学解决一切苦难。我不认为科学是人类的归宿。 从这个角度上来说，我相信自然和进化的力量，它们理应得到比如今高得多得多的尊重和敬畏。我感叹那些在大地上硬生生劈下河流裂谷、挤出山丘高原的地质作用——它们远远、远远、远远地超出一个个体生命的长度，也远非以人类的意志为转移；我惊叹于上亿年进化和自然选择的丰功伟绩，它使我能够写下这篇文章，并且——近乎魔法般地——使这篇文章出自一块像豆腐一样的三磅重的器官，这个器官比节能灯还要节能，却能够产生意识，让我们感受到生命的存在。 从这个角度上来说，这些年来阅读科幻文学作品（尤其是认知论科幻和新浪潮科幻——它们通常带有对科学沙文主义的反思）和人道主义文学以及诗歌的经历或许终于使我理解了两年前高三语文老师在课堂末尾说的 科学不能救人，科学弊大于利 是在说什么。当时我指责她，你不能一面享受科学带来的诸多利好——节能灯、建筑和抗生素——一面对科学大放厥词。 而现在，我想的是 如果人类要有一个归宿，那应该是自然。 我独自漫游，像山谷上空悠然飘过的一朵云霓，蓦然举目，我望见一丛金黄的水仙，缤纷茂密；在湖水之滨，树阴之下，正随风摇曳，舞姿潇洒。 连绵密布，似繁星万点在银河上下闪烁明灭，这一片水仙，沿着湖湾排成延续无尽的行列；一眼便瞥见万朵千株，摇颤着花冠，轻盈飘舞。 湖面的涟漪也迎风起舞，水仙的欢悦却胜似涟漪；有了这样愉快的伴侣，诗人怎能不心旷神怡！我凝望多时，却未曾想到这美景给了我怎样的珍宝： 从此，每当我倚榻而卧，或情怀抑郁，或心境茫然，水仙呵，便在心目中闪烁——那是我孤寂时分的乐园；我的心灵便欢情洋溢，和水仙一道舞踊不息。 ——《水仙》，威廉·华兹华斯 &lt;全文完&gt; 笔者并不精通文中提到的任何一个学科，诸如社会学、哲学、科学史等。正是由于笔者视野狭隘且懒惰成性，对于任何一个方向都不肯努力钻研，文中观点难免片面偏颇。考虑到本文是作为一篇自我陈述而非观点论证组织和行文，关于这一点，还请读者理解。 主要引述来源本文中的大部分知识性和人文性内容来自个人大量散漫、无章法、偶然的阅读，以下列出一些仍能考证的来源，并强烈推荐感兴趣的读者前去阅读这些材料： Blau, P. M., &amp; Duncan, O. D. (1967). The American occupational structure. Fjelland, R. (2020). Why general artificial intelligence will not be realized. Humanities and Social Sciences Communications, 7(1), 1-9. 《牛顿研究》，亚历山大·科瓦雷。商务印书馆2016年版，《科学史译丛》系列。https://www.cp.com.cn/book/72a7bc67-2.html 说真的，要说到什么出版之类的东西，国内真就只有商务印书馆能做到尽善尽美的程度…… 这套商务印书馆出版的《科学史译丛》是我自从识字以来所读过的所有出版物中质量最好、唯一能真正堪称完美的。无论是装帧、纸质、印刷、翻译、校对、各种页码和标记都极其完美。真的很敬佩商务印书馆能如此认真地对待文字出版工作。 《牛顿综合的意义》，亚历山大·科瓦雷。这篇文章是《牛顿研究》的序言，是科学史领域最为著名的文章之一，强烈推荐阅读。 《新物理学的诞生》，伯纳德·科恩。商务印书馆2016年版，《科学史译丛》系列。https://www.cp.com.cn/book/49aa93d4-e.html 《环球科学》2018年7月号，《六个最重要的科学问题》 《环球科学》2014年7月号，《自主意识不存在？》 《科学的价值》，理查德·费曼。收录于费曼的自传《你好，我是费曼》，南海出版公司2016年版。 《我们谈论了这么久的科幻到底是什么？》机核GADIO播客，2018-06-25。https://www.gcores.com/radios/102374 《科幻世界》2020年5月号，《三位科幻作家的“三体对话”》 埃德蒙·胡塞尔。https://zh.wikipedia.org/wiki/%E5%9F%83%E5%BE%B7%E8%92%99%E5%BE%B7%C2%B7%E8%83%A1%E5%A1%9E%E7%88%BE 《索拉里斯星》，斯坦尼斯拉夫·莱姆。 《与拉玛相会》，亚瑟·查理斯·克拉克。 《水仙》，威廉·华兹华斯。https://www.britishlibrary.cn/zh-cn/works/i-wandered-lonely-as-a-cloud/","link":"/life/me-and-the-world/"},{"title":"[选译] Nature 论文：关于动物同性性行为演化的另一种假说","text":"译者按：这篇论文最早是微信公众号「Nature自然科研」在每周新闻中推送给我的，是刊发于2019年11月号《自然：生态学与演化》（Nature Ecology &amp; Evolution）上的「观点（Perspective）」文章。我前天一个晚上看完了，看完总有种大脑升级的感觉，幼小的心灵受到了极大的震撼……. 花了三天，选译了几个比较有意思、比较重要或者单纯比较令人震惊的段落，放上来，各位当个“奇文共赏”就好。 论文原文：Monk, J.D., Giglio, E., Kamath, A. et al. An alternative hypothesis for the evolution of same-sex sexual behaviour in animals. Nat Ecol Evol 3, 1622–1631 (2019). https://doi.org/10.1038/s41559-019-1019-7 译者对原文内容、价值观不负责任，仅对翻译本身负责。 以下是选译的段落。译文中省去了所有的引用注记，并以 [粗体方括号] 标明跳过不译的段落。译文中粗体和斜体均为译者所加。 关于动物同性性行为演化的另一种假说作者： Julia D. Monk1, Erin Giglio 2, Ambika Kamath3,4, Max R. Lambert 4 and Caitlin E. McDonough5 摘要： 相同性别性行为（same-sex sexual behaviour, SSB）在超过1500种动物物种中均有记录，具有同性性行为的物种分布广泛，涵盖了大部分的主演化支（major clade）。演化生物学家长久以来渴望探明“同性性行为（homosexual behaviour）”的适应性根源，以期解决这个看似有悖于进化论的难题：相同性别性行为（SSB）是如何反复进化出来并长久存在，尽管我们假定这一行为会降低物种的适应度（fitness）？这一问题隐含地假设“异性的（heterosexual）”或排他的不同性别性行为（exclusive DSB）是动物的基本情形，而SSB自其演化而来。我们质疑这种将SSB必定视作演化难题的观点，并提出：事实上，相关文本对SSB的代价、收益和起源（costs, benifits and origins）做出的假设是未经检验的。有别于此，通过视角的微妙变化，我们为SSB的进化起源提出了另一种零假设（null hypothesis，指希望能证明为错误的假设，详见零假设 - 维基百科——译者注）：我们不认同SSB的起源和维持是一个需要解决的问题。我们认为，常见的，认为DSB是远古时期的基本情形的隐含假设，并未经严格审视；我们提出的假说认为指向所有性别的无区别性行为（indiscriminate sexual behaviour）才是远古时期的基本情形。如此，通过移动我们借以研究动物性行为的镜头，我们可以更有成果地研究不同性策略的演化历史。 自从查尔斯·达尔文（Charles Darwin）首次认识到自然选择和性选择是渐进式变化的引擎，演化生物学界对性和适应度的考察大都聚焦于个体之间、被认为能产生可受精配子（fertilization-compatible gamete）的性行为，这一行为通常被冠以“异性恋（hetrosexuality）”之名。为避免与通常用于人类性特征的名词混淆（方框1；有译文，见下），且更加精确地描述个体间的特定交互，我们称此类行为为不同性别性行为（DSBs；方框1）。因为个体适宜性被广泛理解为一个与个体生存和繁衍有关的函数，潜在地导致新的后代的诞生的DSBs，清晰地表明其对适应度的影响。然而，动物通常具有一系列的性行为，它们无法被归类为DSBs，亦无法直接导致成功的繁殖。这些性行为包括个体与相同性别、不同物种、尸体、无生命器物发生的性行为，以及自慰行为（self-stimulatory behaviour）。相同性别性行为（SSBs；方框1）是最广泛目击、最深入讨论的非DSB性行为中的一个。SSB在动物中分布广泛，超过1500种动物物种有记录在册的目击报告，包括所有的主要脊椎动物演化支以及多个无脊椎动物物种群（图1和表1；有译文，见下）。这些目击报告来自被捕获个体、实验室环境以及在多种生态条件下的野生动物种群；然而，大部分已知的SSB目击是偶然的，缺乏系统观察。 随着对SSB之普遍性与日俱增的认识，演化生物学家在解决被经常视作演化难题或“达尔文式悖论”的问题上下了更多功夫：为何SSB能够演化并持续，即便它并不能引向成功繁衍并因而降低个体的适应度？况且，若群体中所有个体仅参与SSB，种群将会灭绝。试图解决这一悖论的尝试通常以特定于某分类层级（taxon）的形式，试图找到SSB的，与适应度有关的（adaptive）解释或与适应度无关的（non-adaptive）解释。概括地说，与适应度有关的假说（如亲属选择（kin selection）、等位基因超显性（overdominance）、同种性别内冲突（intrasexual conflict）、两性冲突（sexual antagonism））认为SSB之所以进化出来，是因为它间接地有益于适应度。这些假说假定，在一定的进化时间内，与SSB直接或间接相关的等位基因（ellele）和表观遗传学修饰（epigenetic mark）对其自身的延续有益。相比之下，与适应度无关或与不良适应度有关的假说（如身份错认（mistaken identity）、监狱效应（prison effect；在方框1中有相关介绍，见下）、感染）认为SSB是一种“根本上错误的策略”，并断定它们要不源于基因多效性（pleiotropic effect），要不源于动物生物学其它方面的限制。 许多这些解释性的假说构建于少数关键假设之上，这些假设大多隐含于文本，而非明确叙述。首先，SSB研究似乎认为SSB高消耗是理所当然的——与适应度有关的假说据此假定SSB的益处必须非常高才能为其存在辩护，而与适应度无关的假说则假定，一旦可能，自然选择将强烈对抗SSB。其次，这些假说似乎假定SSB在多个动物谱系（lineage）中有独立的起源，进而将SSB视为一种特性，它在每一个研究系统中独立存在，发源于一个是排他的DSB（exclusive DSB，方框1）的远古种群，并随后通过与演化或有关或无关的过程变得更加普遍。 我们质疑这些假设，并提出了另一种对SSB之普遍性的新解释：远古的动物种群，其性行为既包括DSB，又包括SSB；不同的进化过程，或适应地或非适应地，塑造了如今SSB在不同谱系中的延续和表现，但对其起源的解释，是不必要的。诚然，当我们检视在一个演化支中如此普遍的特定特性时，一个合理的假说就是这样的进化模式很可能缘起于这一进化支的起源；然而，就我们所知，这样的假说或许并不适用于SSB的进化。最简单的假说未必正确，SSB源于一个单一进化源，这样的假说无疑是SSB研究中被忽视的考量。 更进一步，我们讨论了此种假定远古群落的性行为包括DSB和SSB两者的假说，将会如何重塑科学家对现存分类层级中SSB的认知。借此，我们致力于重新定义SSB研究中的零假设——简单来说，我们提出了一种从 “为什么有SSB？” 到 “为什么不呢？” 的视角转移。在我们共有的零假设模型内，在性行为研究的不同方面中，这样的视角转移已被多次主张（例如，配偶选择中的任意特性选择（arbitrary trait choice in mate selection）及雌性配偶选择的存在本身（the existence of female mate choice）、领地意识（territoriality）、雌性多次交配（female multiple mating）），并促使这些领域的实证研究发生变革。我们坚称，这样的视角转移，这样对什么是性行为基本情况的看法的转移将激励SSB研究领域内新假说和新方法的诞生——无论我们的预测是否正确，这些新假说和新方法都将帮助我们更好地理解动物性行为的多样性。 方框1：术语和声明我们意识到，在讨论各种动物的性行为的同时，维持一种对人类生理性别（sex；此翻译参照此处，下同。——译者注）、性向（sexuality）和社会性别（gender）的包容性视角，是相当复杂的。考虑到这点，我们努力在不排除重要的人类语境的同时，将人类性向和其他动物的性行为区分开。为避免不恰当的拟人，我们在人类社会性别和性向，与科学上的性别和性行为术语间划下了清晰边界：前者是基于个人特质、吸引力，以及性偏好和浪漫关系偏好的自我认知，后者则用于指称在非人类动物（见方框2；同有译文，见下）中发现的特定属性和特质。因此，除非用于引用，我们特意避免在手稿中使用如“异性的（hetrosexual）”和“同性的（homosexual）”一类的名词。作为替代，我们诉诸于术语相同性别的性行为（same-sex sexual behaviour，SSB）和不同性别的性行为（different-sex sexual behaviour，DSB），它们更加精确地描述了有关性互动的发现。 特别地，考虑到为涉及超过两个个体的性行为分类将会相当困难，我们使用术语SSB、DSB指代个体间离散的性互动。当考虑一个个体的完整生命周期、或一个种群中的多个个体时，由个体或群体表现的SSB - DSB程度成为了一个连续谱式的——而非二元式的——特性（图2a；不译）：注意到SSB和DSB并不是相互排斥的行为是重要的；还要清楚，DSB之广泛性并不能在任何意义上预测SSB广泛与否，反之亦然：表现出SSB的动物有时可能会表现更多的DSB，高于通常假定的程度。我们使用术语 排他的DSB（个体水平：一个个体的所有性行为都是DSB；群体水平：一个群体中的所有个体仅参与DSB）和 排他的SSB（个体水平：一个个体的所有性行为都是SSB；群体水平：一个群体中的所有个体仅参与SSB）来描述该性行为连续谱两端的理论极端情况。 人类性行为的文化构造影响了有关SSB演化的假说，特别是对于社会性脊椎动物和其它灵长类动物而言。大量有关SSB演化的解释使用人类——而不是其它物种——作为研究系统，这导致一些概念明显源于人类的社会-政治话语。例如，所谓“监狱效应（prison effect）”，声称个体在被剥夺了与不同性别的个体交配的机会后会参与SSB，就是出自单一性别场合，比如监狱，会鼓励囚犯之间的“情境性同性恋（situational homosexuality）”这一流行观点。我们注意到准确且道德地衡量人类性行为臭名昭著地困难，这使得很难控制变量；而监狱通常的强制性意味则更加剧了这些问题。源自历史，这种对人类性行为的聚焦通常使得演化生物学家仅仅通过一个单一端点（个人将“单一端点”理解为“人类”。——译者注）的社会语境来理解一种动物界广泛存在的行为。 由于无法避免的职责偏见将影响所有领域的研究者塑造他们观点的方式，我们希望读者明认：即便作者们性别、性向和子学科方向各异多样，我们均是顺性别的生物学家，且主要在欧美文化语境和科学传统中接受教育。我们的目标是：我们在此呈现的观点能引领一场对动物性行为之多样性、功能和演化的深刻审慎的讨论，这样的讨论定要包容人们多样的生理性别、心理性别和性向。 图1 表1 本表中存疑的“通称”译名将在括号中给出原文。 震惊的地方要来了！！兴奋地搓手手（大雾（（光速逃（（（ 表1 | 由横跨动物系统发生树（phylogeny）的各类多样的物种（与图1对应）表现的SSBs，以及详细记录这些行为的引用（译文中省去） 图示 通称 物种名称 行为描述 1a 绿海胆 Lytechinus variegatus 这些海胆是扩散型产卵生物（broadcast spawner），通常在释放配子前聚集在一起。这样的聚集反映了群体中的性别分布：没有证据表明海胆可以区分潜在伴侣的性别。 1b 小笠原狐蝠 Pteropus pselaphon 在野外，雄性狐蝠在仅有男性的社交种群中舔同性的生殖器——勃起的阴茎。 1c 拖鞋贝壳（Common slipper shell） Crepidula fornicata 拖鞋贝壳是序贯雌雄同体生物：先作为雄性性成熟，随后过渡到雌性。较小、较易活动的雄性会与更大的个体聚集，永久交往和交配。当可以选择时，一小部分的雄性选择与其他雄性交往。 1d 美洲大赤鱿 Dosidicus gigas 观察到雄性在其外套膜（mantle）上有可见的精子囊，表明该个体与另一雄性交配；精子囊与通常沉积在雌性体内的位置相同，数量相似。 1e 束带蛇、园丁蛇（Garter snake） Thamnophis sirtalis 该物种的交配通常发生在大量雄性聚成球形，试图与一条单条的、处于中心的🐍交配，大多是雌性，但有时也有雄性🐍释放与雌性相似的信息素。 1f 雪雁 Anser caerulescens 有报告称目击雄性-雄性配对和雌性-雌性配对，共同抚养两个个体的后代。 1g 豆娘 Ischnura elegans 在该物种中，模仿雄性颜色模式的雄形（andromorphic）雌性在某些情况下会很常见。雄性经常与其他雄性交往并配对，尤其是当存在许多雄形雌性时。 1h 黑背信天翁 Phoebastria immutabilis 在瓦胡岛（Oahu）上的一个黑背信天翁种群中，成对抚养后代的配对中有近三分之一是雌性-雌性配对。参与这种配对的雌性能每年繁殖后代。 1i 赤拟谷盗 Tribolium castaneum 雄性经常与其他雄性配对，并试图与其交配。观察到包括释放精子在内的雌-雄交配行为的发生。 1j 田蟋 Teleogryllus oceanicus 雌性蟋蟀经常相互求爱，包括求爱鸣叫，求爱姿势以及坐骑。 1k 家牛 Bos taurus 当部分或所有雌性处于发情期时，混合性别的牛群中的个体有时会聚集成纯雌性的亚群体。在这些亚群体中，雌性间会表现与公牛交配时相同的求偶行为，包括舔生殖器，摩擦下巴和坐骑。 1l 海星 Archaster angulatus 虽然海星是扩散型产卵生物，但此物种中的雌性确实会在释放配子之前与雌性配对，配对会保持原位长达24小时。在野生条件下，雄性-雄性配对并不罕见。 1m 日本猕猴 Macaca fuscata 雌性猕猴间会规律性地配对并形成暂时但排他的关系。在此期间，它们会进行以骨盆抽动结束的同性间坐骑。雌性将与雄性竞争获得其它雌性的机会，有时会优先与雌性配对，而非与仍未配对的雄性。 1n 南极企鹅 Pygoscelis antarcticus 著名的中央公园动物园（Central Park Zoom）的两只圈养的南极企鹅形成了配对，并试图孵化一个卵。 当从另一个巢获得可育卵后，它们成功共同抚养了一只小🐧。在有进化关联的巴布亚🐧和阿德利🐧中，同性配对也很常见。 1o 大蟾蜍 Bufo bufo 抱合（amplexus）时，雄性蟾蜍不会区分性别、接受性或物种。抓住后，被其他雄性坐骑的雄性会使用特定的信息素以使自身被释放。 1p 大鼠肠道蛔虫（Rat gastrointestinal roundworms） Nippostrongylus brasiliensis 蛔虫太恶心了，最讨厌这些东西了。不译=_= 1q 裂唇鱼 Labroides dimidiatus 该物种是序贯雌雄同体生物，先以雌性性成熟，在没有常驻雄性的情况下，最大的雌性会转变为雄性。然而，这些雌性会开始与其他雌性一起产卵，并在生殖转变完成前就承担起“雄性”的求爱角色和行为。此行为发生在移除雄性约一小时后。 1r 箱蟹 Calappa sp. 观察到雄蟹间相互交配的时长超过连续的18天。 注意：本表格并未穷尽表现出SSB的物种。 一个关于性行为演化的新模型我们提出，无区别性行为，或不含基于性别的配偶选择的性行为，将导致SSB和DSB两者，这最可能是有性生殖生物的祖先的情形。我们推断，现有模型中假定的彻底靶向的DSB，更可能是一种衍生特性：这一特性出现在一个异配生殖（anisogamous）、多细胞、无行动能力的远古物种进化出性行为之后。总的来说，考虑到排他的DSB要求配偶鉴别（分子层面的受精相容性以外的机制），逻辑上，它仅可能在可察的多样化性征（比方说，身体大小和形状，颜色，化学和听觉信号，等等）进化出来之后发生。支持这些基本原则的证据来自棘皮动物——一个与脊椎动物有关的分支谱系，它具有可能类似于祖先生物的特征，而性行为正是演化自这些特征（方框2）；此外，这类动物已被发现既表现SSB，又表现DSB。 更进一步，我们提出生态学或社会学语境下的自然选择，仅会在SSB的代价高昂得无法承受时才会对抗之。若一些特定谱系缺乏这样的代价，SSB可能延续，因为生殖适应度最大值的出现，似乎要求特别靶向受精相容的伴侣（DSB）这一代价，和更多的交配机会（SSB）这一收益之间的平衡。因此，不同程度地横跨个体的生命周期，不同程度地涉及群体中的各个个体，DSB、SSB的双重表达，或许才是大多数动物物种的常态（norm）。这代表了在远古环境下无差别性行为依然保持或中性，或——在一些情况下——有益的这一遗产。 SSB的代价和收益我们的假说缘起于对性行为代价和收益的相对考量。对于SSB，大部分研究的隐含假设是SSB代价高昂，激发了对同样大的益处的探寻，以为高代价的SSB的存在辩护。在解释SSB于一些特定演化支——特别是一些具有复杂社会系统的物种，比如灵长类，在这样的物种中SSB的潜在益处较易鉴别——内的普遍性时，为解释SSB的进化提出的与适应度有关的假说或许确实有一定价值。然而，当我们特别考虑祖先物种是无差别性行为这一可能性时，SSB的延续并不需要很高的益处来维持。相反，我们认为SSB的代价在很多情况下能够达到最小，特别是在一些特定物种中：这些物种相较于生殖产出，其个体具有较高的交配频率。因此，SSB的普遍性和延续性可以在很大程度上由祖先起源，和自然选择的较弱对抗来解释：自然选择不会同这样一种适应代价远低于其它影响繁殖成功率的因素（如不孕不育和配偶竞争）的特性作对。 SSB的潜在性低代价这一认识，在大量研究异种性行为——不同物种间的性行为——的详尽文本中可见一斑。尽管确实有实例，表明了异种性行为的高代价（被冠以名词 “生殖干扰（reproductive interference）”），新近研究同样表明在一些分类层级中，异种性行为能够延续，因为其代价低于减少交配的成本和构建用于识别同物种配偶的额外机制的成本。例如，一项近期研究发现，当将密切关联的南瓜虫（squash bug）物种放在一起时，异种交配相当普遍，但参与该行为的个体与同种个体的交配率也很高，并且和不允许与同种个体交配的个体具有相似的孵化成功率。与之类似，对于那些不在个体的单次交配尝试上下过高赌注的物种，SSB也会具有较低的代价。 DSB的代价和收益一些假说，不论与适应有没有关系，在解释SSB的演化时，通常都基于一个隐含的前提：远古时的情形是一个排他DSB的群体，遭受了编码有SSB的等位基因的入侵；前后比较，较少的DSB与适应度降低紧密相连。这样的假定同样体现在描述性行为的少数模型中：这些模型假设DSB，特别是“紧盯雌性”的雄性，会快速进化，因为远古时期的扩散型产卵所导致的高交配后精子竞争（方框2），会带来很大的选择压（selection pressure）。这些模型假设正因DSB是生殖所必需的，自然选择会高度青睐高水平的DSB；不仅如此，它们还假设盯雌性盯得更紧的雄性——意味着更高水平的DSB，会提升繁殖成功率。 然而，事实通常并非如此——诸如配偶竞争、交配顺序、交配年龄、配子质量、精子浓度以及由雌性主导的交配后选择对DSB能否最终引向后代的诞生起着关键作用。更进一步，在许多动物物种中，DSB并不仅仅服务于一些独特场合下的受精，它可能还有着多种非生殖的功能：这表明“过度的”性行为并不会显著降低适应度。相反，不断增加的配偶甄别和性别特定的性行为是有代价的：错失的交配机会，以及行为学和形态学上的第二性征的建构（不同性别的个体籍此确信配偶确实是不同性别）。例如，当雄性埋葬虫（burying beetle）注意到错失与雌性交配的次数上升时，会更多地参与SSB；这表明在交配机会稀缺的情形下，排他DSB可以是不利的。 综上所述，我们认为：尽管DSB的增多能够最大化受精的可能性，并且，由此推断，能使适应度在一些——或许是广泛——条件下达到最大，并不说明更多的DSB是引向更高适应度的唯一可行措施。排他DSB，与其说是表现了有性生殖动物的基本策略，不如说是代表了一种必须在第二性征发育完全之后才能出现的次生特性，而且这种特性仅在一些特殊语境下才是适应性的。 移动基线时至今日，演化生物学家总在问SSB为什么能够进化，SSB为什么能够延续，而不管其明显代价。通过质疑SSB的“明显代价”终究是不是如此明显，我们反对这种观点。我们要问的是，构建代价高昂的配偶识别系统并通过高选择率潜在地限制交配机会，是否，以及何时，能够进化，尽管性行为的通吃策略能有足够高的受精机率和足够低的代价。这正是我们论点的关键：任何为解释动物SSB的“目的”而提出的与适应有关无关的假说，或许能很好地解释其延续性，包括SSB附带的非生殖功能；但是，SSB并不缘起于产生这些功能的较近的演化事件，而是源于性行为的最早形式。 这种看似微妙的区分基于一关键概念：正在经历演化变化的一个群体，其初始条件对其演化轨迹，有着关键的，甚至是方向性的影响。演化轨迹的预期代价、收益和可能性之间的差异，依赖于我们是否假定自然选择会青睐某种初始时罕见的特性，或者抵抗某种初始时常见的特性。因此，通过移动有关这些性行为起源的假设，我们的假说极大地改变了选择性机制，如今在动物中见到的性行为的多样性正是由此而生。 我们的理论与此先指出研究狭隘地聚焦于适应性进化的批评一致。这样的对于适应的关注，会导致一种倾向：即将现存特质解释为在较强自然选择下，近期演化变化的表征；而不是出自较弱或缺乏选择、不断浮动的选择压和生物学限制的特性。在基于一种SSB主要是中性的假说，在不同的演化支和生态学语境下，青睐DSB、抵抗SSB的选择或许很强，抵抗SSB的选择或许可忽略，在一些情况下青睐高度或特定类别SSB的选择或许很强。事实上，早先曾有研究提出，SSB最早是作为非人类灵长类动物的中性变异出现的，随后各种新兴的群体性行为带来的益处增强了对该特性的定向选择。我们外延这一假说，提出配偶行为的这一变异，是所有有性生殖、雌雄异体动物的祖先。因而，我们预测，动物性行为令人震惊的多样性，是多种程度的适应性或非适应性过程（包括基因漂变）对当下个体、种群和物种的DSB - SSB连续谱持续性选择的结果。 方框2：定义与性生殖有关的性行为动物内和动物间繁殖模式和系统令人惊讶的多样性，提示了准确定义性行为会令人沮丧地困难。总的来说，由于人类更容易辨认出和我们具有相似性行为方式的物种的性行为，我们注意到观察者偏差在动物性行为的鉴别、描述和理解中广泛存在（方框1）。因此，我们尝试建立对动物性行为的有效定义，以及性和性生殖的概念：这些定义既要能反映自然变异，又要能表明大多数生物特征是如何连续变化的。 我们使用广义的动物性行为定义：任何可能对成功繁殖有贡献的行为；这些行为——不论在何种情况下观察到它们——可能出现在交配时、求爱中或配对间。成功的繁殖要求通过性生殖达成后代的诞生：形成后代的遗传物质的组合，通常源自大小不同的配子的融合（异配生殖）。因此，特别是对个体仅产生一种类型配子的雌雄异体系统，性这一概念定义于它们产生的配子类型：雌性（典型地，带有较大细胞质的配子（卵子））、雄性（更小的，主要是DNA的配子（精子））。要注意到，这些定义无法充分描述不产生配子的生殖行为，此外，在多个分类层级中，对性别的可行定义通常依赖于更加明显的第二性征。意识到这些局限，围绕本文之主旨，我们将我们对性的理解建构于其基因解释之上，以期广泛理解针对“相同性别”个体和“不同性别”个体的性行为。 借上述定义，性行为必须要等到性生殖出现以后才能进化出来。然而，研究性行为的理论工作令人惊讶地罕见。一个值得注意的例外是帕克（Parker）的模型，这一模型假定运动能力、行为复杂性、交配和内部受精（这一进程包括性行为）是进化自一个异配生殖的、多细胞的、无运动能力的物种。在本文中，我们认为现存动物的、有性行为的最近共同祖先，源自一个相似的进化起源。然而，这并未排除性行为具有多个起源这一可能，亦未断言非异配生殖、非多细胞的生物就没有性行为。重点在于，往下走，我们偏离了帕克模型的逻辑：帕克模型特别假设这一转变必定导致对雄性“紧盯雌性”的性行为的强选择；我们则进一步认为，这些模型反应了一个主流的隐含假设，即性行为仅针对不同性别的个体而演化：这正是我们的假说要质疑的。 [以下对应原文中 “Implications for studing SSB” 段落，包括三级子标题 “Phylogenetic comparisons” 和 “Ecology and natural history of SSB”，不译；此外还有 图2（“ Conceptual representation of the variation in SSB and DSB that is possible at the individual and population, and species levels.”）、图3（“Ecological, evolutionary and developmental factors may influence the expression of SSB.”），均不译] [除上述提及的段落，原文中其它所有文字均有译文] 结束语如果任何一种特性能够出现在如此广泛多样的分类层级中，这一特性是源于最早的动物演化支的远古情形这一点，很可能早就取得了广泛认同——只要该特性不是SSB。视SSB为一种在如此之多不同的谱系中独立趋同进化的观点，只会使得视异性恋为基准的世界性思潮更加根深蒂固：在这样的世界中，“异性的”性行为被定格为有性生殖生物的“自然情况”，而“同性的”则被视为一种必须解释其存在并为其正名的反常情况。因此，横跨演化生物学界的欧美文化规范——视异性恋为基准的、父系的——的持续延续已经影响了有关性行为的讨论，它使得这些讨论主要集中于DSB：一种单一的、被认为文化上可接受的性行为（方框1）。 质疑这些偏见，为有关性行为进化的更简单假说（奥卡姆剃刀。——译者注）创造了空间。随着有关各种物种性行为如何演化的研究不断推进，我们断言，相较于仅表现DSB（排他DSB）的物种，同时表现SSB和DSB的物种更加普遍——前者可能才是自然界中的罕见情况。自然选择不同程度地青睐或对抗DSB和SSB，围绕这一点的各种问题为演化生物学提供了令人兴奋的机遇。由于这一领域相关研究的贫乏，当下任何对我们假说的外延都是可疑的；但是，放松施加在有关性行为的演化理论上的传统限制，无疑会激起对这些行为在动物生态学和动物进化语境下具有如何多样的角色更加广阔、更加彻底的探讨——我们对此感到兴奋。视SSB为一种源于“异性的”、独立进化的、近期才出现的现象，而非各种复杂难解的行为、特质和策略光谱被我们不负责任地归为“性”和“性行为”中的一个受害者，无疑是一种二元本质论的表征——这种论调不仅妨碍社会解放和自由，还会妨碍科学发现。 接收于：2019年6月5日；接受于：2019年9月30日在线发表于：2019年11月18日 全文完。翻译：Ray Eldath。 译注：注意，本文并不是所谓的「original research article」，即「原创研究论文」，而仅仅是一篇review性质的“Perspective”——这点从本文较短的长度中就可以看出来，详细的举例和论证应该引文中。为方便，本文翻译时去除了所有的引用注记，这可能使本译文显得缺乏证据。 需要强调的是，作为一篇「观点（Perspective）」文章，本文的最大意义和最终目的，并不在于足够充分、足够彻底地举证以证明文中提出的新假说；而是在于通过提出当下该领域研究的很多理所应当的假设，事实上是未经检验的，来激起对「另一种可能」的探讨。文章的目的在于使人们注意到这样的另一种可能，并期望后续更深刻、彻底的研究能对这种可能性进行实证的——无论是支持还是反对——证据搜集和论证。正如作者们说的： 更进一步，我们讨论了此种假定远古群落的性行为包括DSB和SSB两者的假说，将会如何重塑科学家对现存分类层级中SSB的认知。借此，我们致力于重新定义SSB研究中的零假设——简单来说，我们提出了一种从 “为什么有SSB？” 到 “为什么不呢？” 的视角转移。 …… 我们坚称，这样的视角转移，这样对什么是性行为基本情况的看法的转移将激励SSB研究领域内新假说和新方法的诞生——无论我们的预测是否正确，这些新假说和新方法都将帮助我们更好地理解动物性行为的多样性。…… 我们的目标是：我们在此呈现的观点能引领一场对动物性行为之多样性、功能和演化的深刻审慎的讨论，这样的讨论定要包容人们多样的生理性别、心理性别和性向。 校对的时候发现好几个DSB给打成DSL（领域特定语言）了。。太搞笑了，😅😅 居然差不多一万字了。。。。惊了，如果翻译也算是我的东西的话，那连续两篇文章破记录，本身也算是“破纪录”了吧？哈哈。 总之就是这样，祈愿本学期能不挂科吧。 最后来看一下论文文末的“致谢（Acknowledgements）”： This project could not have come to fruition without many dynamic and thought-provoking conversations with natural and social scientists, feminists, LGBTQIA+ activists, friends and family members. We particularly thank A. Wesner and the members of the Queer Ecologies Working Group within the Social Science Matrix at UC Berkeley, who facilitated a workshop and…… 我就知道。","link":"/science/monk2019/"},{"title":"本博客评论区现已支持邮件提醒","text":"Valine 作为一个无后端、轻量简洁开放的评论插件确实好用，然而也正是因为这简单轻量的评论系统，本博客的评论一直没有通知功能。很长一段时间内我都靠「人肉轮询」来处理回复，经常很久以后才看到可爱读者们留言，而我的回复也难以传达。今天终于决心解决这个问题，原本想着跑个 Valine-Admin ，然而恰逢我使用的 hexo 主题（魔改了一些 CSS）终于支持了 Waline 这个进化自 Valine、拥有更好的界面和更多功能且原生支持邮件提醒的评论插件，在用 sed（甚至写进了本博客使用的 GitHub Actions pipeline 里边…）更新了这 hexo 主题依赖的老旧无比的 Waline 版本之后，这儿终于有带提醒的评论区了。 唯一一点遗憾是，即便我已按照 GandiMail（本域名的服务商 Gandi.net 附赠的域名邮箱服务）的要求设置了 SPF 记录等各种 DNS 条目，本博客的评论提醒邮箱 no-reply@ray-eldath.me 还是会被 Outlook 归为「垃圾邮件」。我们 Ray 真是太可怜了，希望这只是个个例。也请此后在这留言的各位读者们更加勤快地查看自己的垃圾箱 （看看有没有 Ray）。 希望我的拖延症能快点好。","link":"/notice/now-support-email-notice/"},{"title":"从 SML 到 Scala：简单考察 typeclass 范式的演变和各种实现，以及🎉🎉🎉","text":"本文是一篇「小作品」 这次要是还写巨长我就吃了渚薰（（（（大雾） Typeclass 范式是对于 表达式问题 Expression Problem 的一个重要的解。在我了解的编程语言范式中，个人认为，typeclass 范式是较为优雅的一个。本文将简要考察这一范式本身，以及更加重要的：它在各种编程语言中到底如何落地。具体而言，本文将在各种落地语言中构造同一个示例：一个类似 Ruby 中的 Comparable mixin，或者 Java 中的 Comparable 接口，并且演示这些结构如何对既有的类型同样具备可扩展性。 阅读本文需要一定的代码基础，尤其是对 typeclass 范式的认识和相关的编码经验。本文并不会对文中的举例作详尽解释。 表达式问题 Expression Problem先来简单说说表达式问题。表达式问题是编程语言设计中的一个重要问题，它非常直接地与我们日常的编程工作联系起来——这也是其之所以重要的一大原因。这一问题最早是由 Philip Wadler（是的是的，就是那位 Mr.λ wwwwww，不知道他的这点轶事的朋友可以去油管上看看他的 talk Propositions as Types（话说我最早是看 Facebook 的一个介绍 Haskell 在他们内部大规模生产级落地的 talk 知道这位 Mr.λ 的，那个 talk 也相当不错，大家也可以去看看~））在讨论 Generic Java（好像是 Oracle 给 Java 泛型这块设计的项目取的代号）的设计时提出的。表达式问题提出的背景是使用一门编程语言提供的表达能力来表达一个表达式系统（Expr），这个系统需要具有可扩展能力（这正是名字中 表达式 的来源）。简单来说，表达式问题考察：一个语言如何支持扩展一个既有的类型（datatype），常见的操作是，向这个类型增添子类型（case），或者向所有的类型增添操作（通常以方法的形式）。 将这个统领表达式的类型（Expr），按所有的子类型（case）和所有的操作（operations）两个维度分别列全，就可以得到一张表，这张表格的行即子类型列即操作。广义来讲，这张表格很好地表明了函数式编程 Functional Programming, FP 和 面向对象编程 Object-Oriented Programming, OOP 之间的完全对立甚至是正交——一个偏重行（即子类型）的可扩展性，一个偏重列（即操作，通常是方法或函数）的可扩展性（当然，前提是你要同意，Java 不代表 OOP，而 FP 和范畴论、Monad、Functor 等各种有用没用的概念并没有什么关系）。 这可能是本文（或者是本博客？）所有文字中最重要的一句废话： Java 不代表——至少不完全代表——OOP，而 FP 和范畴论、Monad、Functor 等各种有用没用的概念其实并没有什么关系。 具体见文末 “主要引述来源”。 Typeclass in SML: Module SystemML 族语言自 1970 年代，LCF 定理证明器（theorem prover）的元语言（Meta Language）演化而来。SML（Standard ML）以及 ML 族语言，作为 严格求值（strict evaluation）、静态类型的函数式语言的典例，启发了大量语言的设计，并对编程语言的形式化定义和验证等研究方向做出了重要贡献。 SML 的 模块系统 Module System 为语言细节的隐藏提供了强大的工具（SML 的模块其实很有意思，比较值得学习研究），它或许是历史上第一个提出（并实现）这一范式的编程语言： typeclass.sml12345678910111213141516171819202122232425signature COMPARABLE = sig type elem val compare: elem -&gt; elem -&gt; intendfunctor Ord (X: COMPARABLE) : sig val le: X.elem -&gt; X.elem -&gt; bool val eq: X.elem -&gt; X.elem -&gt; bool val ge: X.elem -&gt; X.elem -&gt; boolend = struct fun le x y = X.compare x y &lt;= 0 fun eq x y = X.compare x y = 0 fun ge x y = X.compare x y &gt;= 0endstructure IntComparable : COMPARABLE = struct type elem = int fun compare x y = case Int.compare (x, y) of LESS =&gt; ~1 | EQUAL =&gt; 0 | GREATER =&gt; 1endstructure IntOrd = Ord(IntComparable) signature / structure 之间的配合是 ML Module System 的重要方面，前者基于类型签名约定了一个接口（同样，不是 Java 意义上的接口…… 每次都要在术语处特别和 Java 划清界限实在是 😒😒😒），而后者则是对这一接口的实现。有趣的是，和绝大多数语言中类似接口的机制的设计不同，这一实现过程并不是简单的要求 “一模一样”，而是存在着复杂有趣的 签名匹配 signature matching 机制。这一机制提供了接口中重要的隐藏方面。 回归正题，我们首先定义 signature COMPARABLE，这类似于 Haskell 中的 class。随后，我们希望为内置类型 int 实现这一 typeclass（这一过程称作 ascription）——我们定义了 structure IntComparable : COMPARABLE（这类似 Haskell 中的 instance），没错，冒号 : 正是 “实现自” 的意思。 至此我们已经完成常规意义下的 typeclass 范式——定义一个接口，并使既有类型实现这个接口。 出于演示目的，我复杂化了这个示例：除了单纯的 typeclass 范式之外，此处演示了基于 typeclass 范式的后半截逻辑：在一个既有类型的 typeclass 实现之上，定义 “任何实现了这个 typeclass 的类型，都具有这些操作”。这是通过一个看起来有点奇怪的关键字 functor 实现的。functor （称作 module function）基于一个已有的 signature 完成这一转换路径：如果一组元素 {A} 在一个类型 X 上有定义，那么 X 上就会有另一组元素 {B}（在这里，{A} = { type elem, fun compare }；X = int；{B} = { fun le, fun eq, fun ge }）。 这个转换路径听起来是不是很像 mixin…？ 以及这个 “后半截” 逻辑听起来是不是很像 Rust 中的 From / Into…？ 在这段代码中，我们首先通过 IntComparable 实现了 typeclass 范式，随后 functor Ord 在 IntComparable 上的实例化（这个语法也很有意思，Ord(IntComparable) 这种结构的语法其实正是在提示这种 “参数传递” 的 “实例化” 意味）完成了后半段：我们使用 typeclass 范式为一个业已存在的类型 int 实现了一组操作，随后基于这组操作衍生出了一组新的操作。 这一示例的演示如下： >folded output from *Standard ML of New Jersey* REPL v110.98.1123456789101112131415161718192021222324252627282930313233343536- use &quot;typeclass.sml&quot;;[opening typeclass.sml]signature COMPARABLE = sig type elem val compare : elem -&gt; elem -&gt; intendfunctor Ord(X: sig type elem val compare : elem -&gt; elem -&gt; intend) :sig val le : X.elem -&gt; X.elem -&gt; bool val eq : X.elem -&gt; X.elem -&gt; bool val ge : X.elem -&gt; X.elem -&gt; boolendstructure IntComparable : COMPARABLEstructure IntOrd : sig val le : X.elem -&gt; X.elem -&gt; bool val eq : X.elem -&gt; X.elem -&gt; bool val ge : X.elem -&gt; X.elem -&gt; boolendval it = () : unit- IntComparable.compare 42 42;val it = 0 : int- IntOrd.eq 42 42;val it = true : bool- IntComparable.compare 2 4;val it = ~1 : int- IntOrd.le 2 4;val it = true : bool 一点局限性在于，我们需要为 typeclass 的两个部分赋予不同的名字：IntComparable 和 IntOrd。重名在 SML 中式不允许的——后出现的定义将会 掩蔽 shadow 掉先出现的定义。 ML Module System 是一个完备、丰富、强大的模块系统，它的能力远远不止于此（比如，sharing constraints 等并未提及）。 最后，顺带一提，我们在一个接口中包含了一个类型（type elem），并且接口中的其它定义依赖于这个类型定义（val compare : elem -&gt; elem -&gt; int），这在很多语言中被称作 联合类型 associated type。 由于 SML 相当冷门（因而更难以熟悉），我们在这一节上花费了大量笔墨。接下来看一看其它语言中的 typeclass。 Typeclass in Haskell: class &amp; instanceHaskell 是一门静态类型的函数式语言，这门语言的最大特点，在于它是 惰性求值 lazy evaluation 的——这是一个不同于绝大多数语言的设计决策。除此以外，高度拥抱犯愁范畴论及相关术语（而不是如 Scala 语言设计者一般在这个问题上相当谨慎，引自 Dean Wampler），同样是这门语言的重要特征（然而正如它的核心发明者之一 SPJ Simon Peyton Jones 说的那样，Haskell 没有学习 F# 采用更加保守的命名而是全面拥抱理论数学，或许是一个相当错误的决定，引文见文末）。 typeclass 这一范式正是由 Haskell “定义”，一般认为 Haskell 语言是这一范式的起源： typeclass.hs12345678910111213141516class Comparable a where comp :: a -&gt; a -&gt; Integerinstance Comparable Integer where comp x y = case compare x y of GT -&gt; 1 EQ -&gt; 0 LT -&gt; -1le :: Comparable a =&gt; a -&gt; a -&gt; Boolle x y = comp x y &lt;= 0eq x y = comp x y == 0ge x y = comp x y &gt;= 0 大部分部分都是不言自明的，在此不做过多解释。显然，得益于强大的类型推导机制和精心设计的语法，Haskell 中实现 typeclass 的代码量是相当小的。 我们仅为 le 标注了类型：类型声明是可选的（虽然建议标出），因为 Haskell 可以帮你推断出来。由于在可变性上采取了更加严格（因而更加函数式）的规定，Haskell 不必像上一节提到的 SML 一样在类型系统上 “开洞”，引入所谓的 value restriction 和 dummy type。 我要用腐朽的声音喊出：**Hoogle 天下第一！！😋** 强烈建议其它所有良好支持 typeclass 范式的语言都要（至少是对语言标准库）有这么一个 class 的查询引擎，避免重复轮子…… 演示如下： >folded output from *ghci* lts-15.91234567891011Prelude&gt; :load typeclass.hs[1 of 1] Compiling Main ( typeclass.hs, interpreted )Ok, one module loaded.*Main&gt; comp 42 420*Main&gt; eq 42 42True*Main&gt; comp 2 4-1*Main&gt; le 2 4True 同样基本是不言自明的。 Typeclass in Rust: traitRust 是主要由 Mozilla 开发、现依托于开源社区和 Rust Foundation 独立运行的面向函数式、静态类型的非托管语言，它直接编译到机器码，并通过精心设计的 所有权 ownership 机制达成了非托管语言难以做到的内存安全（具体可以看看咱博客的 Rust 系列文章 😉）。 Rust 中采用了 trait / impl 原语实现这一机制。个人浅见是 struct 基本等同 record，trait 基本等同 class，而 impl 基本等同 instance，所以说 Rust 的表达力基本没有太多超出 ML 系语言的一般水平。 与上两例不同，Rust 并没有使用 柯里化 curring 为函数传参的传统，亦未为这一特性提供一等支持： typeclass.rs1234567891011121314151617181920212223use std::cmp::Ordering;trait Comparable { type Elem; fn compare(&amp;self, y: Self::Elem) -&gt; i8;}impl Comparable for i32 { type Elem = i32; fn compare(&amp;self, y: Self::Elem) -&gt; i8 { match self.cmp(&amp;y) { Ordering::Less =&gt; -1, Ordering::Equal =&gt; 0, Ordering::Greater =&gt; 1, } }}fn le&lt;TT, T: Comparable&lt;Elem = TT&gt;&gt;(x: T, y: TT) -&gt; bool { x.compare(y) &lt;= 0 }fn eq&lt;TT, T: Comparable&lt;Elem = TT&gt;&gt;(x: T, y: TT) -&gt; bool { x.compare(y) == 0 }fn ge&lt;TT, T: Comparable&lt;Elem = TT&gt;&gt;(x: T, y: TT) -&gt; bool { x.compare(y) &gt;= 0 } 作为一门函数式气氛较弱的语言，强制的显式类型标注（并重复两次）、以及需要通过 泛型 generic 指明类型约束使这段 Rust 代码稍显冗杂——大多数工业级语言都只能做到这个程度。 演示如下： >folded output from *Rust Playground*> Try this on your own 😉1234567891011121314151617181920212223242526fn main() { println!(&quot;{}&quot;, 42.compare(42)); println!(&quot;{}&quot;, eq(42, 42)); println!(&quot;{}&quot;, 2.compare(4)); println!(&quot;{}&quot;, le(2, 4));}------------------ Standard Error ------------------ Compiling playground v0.0.1 (/playground)warning: function is never used: `ge` --&gt; src/main.rs:23:4 |23 | fn ge&lt;TT, T: Comparable&lt;Elem = TT&gt;&gt;(x: T, y: TT) -&gt; bool { x.compare(y) &gt;= 0 } | ^^ | = note: `#[warn(dead_code)]` on by defaultwarning: 1 warning emitted Finished dev [unoptimized + debuginfo] target(s) in 0.77s Running `target/debug/playground`------------------ Standard Output ------------------0true-1true 有关 Rust 的更多内容，欢迎访问 Rust Language 以及查看本博客中 其它有关 Rust 的文章。 Try this on your own 😉: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=07c98bcedef5ca99b40e4988e09d8137 Typeclass in C++ 20 Indian Concept: A Failed Endeavour你可能会疑惑，啥啥啥？？🤨🤨 C++ 啥时候也有 typeclass 了？？？😯😯😯 然而，正如本节的标题所提示的：这是一次失败的努力。语言设计提案最终未能获得 共识 consensus。 来看看这个失败的提案（被称作 Indiana Concept）： typeclass_failed.cpp1234567891011121314151617concept Comparable&lt;typename T&gt; { int operator&lt;=&gt;(const T&amp; x, const T&amp; y);}concept_map Comparable&lt;int&gt; { int operator&lt;=&gt;(const int&amp; x, const int&amp; y) { if (x &gt;= y) return 1; else if (x == y) return 0; else if (x &lt;= y) return -1; }}template&lt;Comparable T&gt; bool le(const T&amp; x, const T&amp; y) { return (x &lt;=&gt; y) &lt;= 0; }template&lt;Comparable T&gt; bool eq(const T&amp; x, const T&amp; y) { return (x &lt;=&gt; y) == 0; }template&lt;Comparable T&gt; bool le(const T&amp; x, const T&amp; y) { return (x &lt;=&gt; y) &lt;= 0; } 其实也蛮简洁的嘛。 为什么没有获得通过？typeclass 它难道不比模板、还有 TMP 模板元编程 这种诡异至极的奇葩 香多了吗？ 这一提案最初于 2006 年正式提出，并最终在 2009 年决定正式从即将发布的语言规范草案中移除。Bjarne 在 HOPL3（详见文末 “主要引述来源”）中无不惋惜地说： That decision cost us three years of hard work and much controversy … We could not agree to “fix” concepts to make them usable by most programmers and also ship the standard (more or less) on time. Thus, “concepts” – the result of years of work by many competent people – was removed from the draft standard. 个人认为，typeclass 范式所倡导的 be explicit 和 C++ 本身一贯执行的 be implicit 哲学之间的阻抗失配不契合是该提案失败的重要原因（我的另一篇博文中对这点有更深入的解读）。HOPL3 中列举的原因有： 各个层面的语言设计进展相当缓慢，关键问题仍未解决。难以达成共识。 一些精心编写的 concept_map 和 late_check 会导致类型系统 不完备（unsoundness）。 现有的这一部分规范极度复杂，长达 91 页。可读性很差。 在标准库中落地 concept 的工作量令人意想不到地巨大无比。 性能极低。 （despite “heroic efforts from Doug Gregor”）启用了 concept 的编译器编译速度比未启用的编译器慢不止十倍。主要的 C++ 编译器供应方表示，只要有超过 20% 的性能损耗，他们就不会同意提案。 后来由 Bjarne 主导设计的新提案取得了长足进展，形成了在 GCC 6 中得以实验性发布的 Concepts TS，并经少量修改最终形成了我们现在见到的 C++ 20 Concepts：concept 被定义为类型的谓词（即 constexpr &lt;type&gt; -&gt; bool。 个人看来这是一个相当精妙的设计思路。很好地利用了 C++ 现有的基础设施：对于 constexpr 的支持。 就和 auto 很好地利用了模板类型推导这一基础设施一样。 Typeclass in Scala 2: implicit“Scala 是 Scala 是一门编译到 JVM 字节码的多范式语言。在所有工业级编程语言中，Scala 以其惊人的复杂度和优雅程度而著称。” Scala 中的 typeclass 范式主要是通过 trait 和 隐式 implicit 实现的。 就和 SML 的 Module System 远远不止 typeclass 一样——Scala 的 implicit 同样如此。Scala 的 implicit 是这门语言最为强大的特性之一，除了 typeclass，它还能够表达诸如 隐式参数 implicit parameter、隐式证据 implicit evidence、类型限定 type constraint、扩展函数 extenstion ，等等等等，好用有趣的语言范式上。 因为隐式的用法实在是太多太混，于是 Scala 3 就把这一个关键字上承担的过多功能分拆到了几个不同的关键字上… 所以，这就是隐式的其中一种用法： typeclass.sc12345678910111213141516trait MyComparable[T, TY] { def compare(x: T, y: TY): Int}object MyComparable { implicit val intIntComparable = new MyComparable[Int, Int] { override def compare(x: Int, y: Int) = x.compare(y) } def le[T, TY](x: T, y: TY)(implicit instance: MyComparable[T, TY]) = instance.compare(x, y) &lt;= 0 def eq[T, TY](x: T, y: TY)(implicit instance: MyComparable[T, TY]) = instance.compare(x, y) == 0 def ge[T, TY](x: T, y: TY)(implicit instance: MyComparable[T, TY]) = instance.compare(x, y) &gt;= 0} 由于隐式本身用法多样带来的复杂性，上边这段 Scala 代码看起来比较复杂。再来看一下演示： >folded output from *Scastie*> Try this on your own 😉12345678910111213141516// Exiting paste mode, now interpreting.trait MyComparableobject MyComparablescala&gt; implicitly[MyComparable[Int, Int]].compare(42, 42)val res0: Int = 0scala&gt; MyComparable.eq(42, 42)val res1: Boolean = truescala&gt; implicitly[MyComparable[Int, Int]].compare(2, 4)val res2: Int = -1scala&gt; MyComparable.le(2, 4)val res3: Boolean = true 在代码和演示中，我们使用了 隐式参数（implicit instance）和一个标准库中的对象 implicitly 查找当前上下文中符合类型要求的隐式。这一过程称作 召唤 summon（是不是很中二啊www 😉）。 Try this on your own 😉: https://scastie.scala-lang.org/YxSlxJPnRXKYn9Lh5dEVig 结语，及主要引述来源为与各个编程语言的惯用法和文化相适应（更加地道），各节中的例子均有一些实现细节层面的修订。这使它们看起来并不完全一样（有一些通过柯里化传参，一些是直接传参；一些方法名为 compare，一些是 comp （为了避免命名空间冲突），一些使用的是 太空船运算符 spaceship operator &lt;=&gt;（这个名字真是太可爱了www 😙））。 顺带一提，这篇文章里的大部分演示，其实都是我看着 Haskell 的那段代码对着写的… Snipaste 天下第一！ 主要引述来源： The Expression Problem, Philip Wadler. http://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt Griesemer, R., Hu, R., Kokke, W., Lange, J., Taylor, I. L., Toninho, B., … &amp; Yoshida, N. (2020). Featherweight go. Proceedings of the ACM on Programming Languages, 4(OOPSLA), 1-29. MacQueen, D., Harper, R., &amp; Reppy, J. (2020). The history of Standard ML. Proceedings of the ACM on Programming Languages, 4(HOPL), 1-100. Notes on SML97’s Value Restriction, Geoffrey Smith. http://users.cs.fiu.edu/~smithg/cop4555/valrestr.html Simon Peyton-Jones: Escape from the ivory tower: the Haskell journey, SPJ Simon Peyton-Jones. https://youtu.be/re96UgMk6GQ 《简单聊聊编程语言的哲学，以及关于 Rust 的一些想法 (1)》, Myself. https://ray-eldath.me/programming/thoughts-on-rust-1 HOPL3: Stroustrup, B. (2020). Thriving in a crowded and changing world: C++ 2006–2020. Proceedings of the ACM on Programming Languages, 4(HOPL), 1-168. No ‘Concepts’ in C++0x, Bjarne Stroustrup. https://accu.org/journals/overload/17/92/stroustrup_1576/ https://en.cppreference.com/w/cpp/compiler_support https://github.com/Ray-Eldath/whatever/blob/master/main/src/main/scala/cats/monad/Monad.sc 一些语言的 Playground（都超级好用！）： Rust：https://play.rust-lang.org/ Scala：https://scastie.scala-lang.org/ Haskell 部分使用 ghci REPL 编写 SML 部分使用 Standard ML of New Jersey REPL 编写 两天啥也没干狂肝两篇博文，可真是把我榨干了。 这个假期应该不会出新博文了… 想静下心来休息下，学点东西啥的。 最后，yet again：各位新年愉快！ ——以及，今天是我的18岁生日，祝我自己成年快乐。🎂🎂🎂🙌🙌🙌🎈🎈🎈🎉🎉🎉 希望今后能学到更多有趣的东西，创造一些更有价值的事物，去到更加遥远的地方，了解更加广阔的世界，认识更多有趣的人——并和他们一起前行。 各位，两周后见！👋👋👋 &lt;全文完&gt; 今天网易云推的歌怎么都那么好听啊 www","link":"/programming/on-typeclass-paradigm/"},{"title":"一无所有","text":"生活是 活了几千年，但又保持着童颜的精灵 她总是给我们不完整的希望： “在巧合的同时， 总有诸多遗憾” 你这样说她，带着一丝忧伤。 ​ 她总是 不屑于理会任何人： 无论是君王高傲的律令 还是人们虔敬的祈求 她从来只会瞟上一眼 满脸鄙夷的神色： 钱财？失去比得到要容易太多； 名声？没人可以带进他的坟墓； 爱情？反正也不可能天长地久； 她要不断地宣告： 我们只能为她而活。 ​ 因为我们是她的孩子， 背着希冀和欲望出生； 我们总在不断地幻想， 一个没有差错的世界： 在那里，我们取代了她的位置， 永远地做着，美好而又不安的梦。 ​ 如若有那么一天， 我们还在做着，万事如愿的沉重的梦， 然而那时的我们， 已经走过了人生的庭园—— 青春的坦荡已消退殆尽， 人生的织物亦几经圆满： 在峥嵘崔嵬的生命之巅， 在灿烂夺目的日光之下， 我们是否会，又一次 一无所有？","link":"/literature/poem-nothing-but-thee/"},{"title":"如果事情起了变化…","text":"如果事情起了变化， 我不再要求 浪花的高低， 而是对湖水的深度 了无期许， 因为我现在，更加想见 融雪在闪耀，荒原在延伸—— 是北国的风景。 ​ 如果事情起了变化， “自由的元素” 不再使我吟唱， 成行的水仙 不再使我激昂， 因为我现在，在用片段 支撑起联系；稍息，立正—— 是断壁残垣。 ​ 如果事情起了变化， 有人说，有人告诉她，像奥氮平片 像行尸走肉； 可是我会说，像犯困，像乍睡还醒时的心神朦胧， 得来要更加简单， 副作用要更好处理。 ​ 如果事情起了变化， 我偏爱人们， 胜过喜欢人类， 旺盛的热情，不竭的关切， 澎湃的言辞，涌动的世界， 是不是已 不再是我的主题？ ​ 如果事情起了变化， 火焰，是绿色的—— 它挑战，律令和道德 它漠视，痛苦和悲伤 它划下，界限和领域 它不受，我的控制 它是，我的火焰。 ​ 炉上的壶子还在 聒噪地呼呼作响—— 可是我看到，它在注视， 并且呜咽。 并且道歉。 并且恳求。 ​ 2021.4.11","link":"/literature/poem-if-things-changed/"},{"title":"Self：编程语言的变革仍未到来","text":"本文是一篇小作品。 本文引用并翻译了在 HOPL III 上发表的论文 Self（DOI: 10.1145/1238844.1238853）中的倒数第二节。在 ACM Digital Library 收录的所有 HOPL（History of Programming Languages） 论文中，这篇论文的下载量排到了第八位。 我将要引用并翻译的段落出自论文的倒数第二节 “8. Conclusion”（8. 结论） 。在读完全文后，我在我的私人群里如此表达我的感受： 首先这里简单用几句话概括一下 Self。Self 语言 是一门基于原型的（prototype-based）、纯消息传递（pure message-passing）的无类式（classless）面向对象语言。这门语言去除了类和对象之间的分立，通过灵活的原型链机制实现了实现复用（reuse of implementation，即继承），并且彻底贯彻了消息传递，抹除了赋值（assignment）和计算（computation）之间的界限——简单性（simplicity）、可理解性（comprehensibility，尽可能贴近现实世界）和统一性（uniformity）是该语言一贯坚持的原则。尽管资助该语言的计划早在 1995 年就被迫中止，Self 依然十分深刻地影响了当今世界上最活跃、最重要的几大编程语言：JavaScript 几乎和 Self 如出一辙，同样抹去了类（class）的存在，同样基于原型链达成了OOP（然而之所以促使 Self 作出这些设计结果的重要原则和思想在如今的 JavaScript 中已经完全得不到体现——这无疑十分可惜和遗憾）；而 Self VM 的实现技术非常直接地影响了 JVM 的实现——诸如 polymorphic inline cache, dynamic optimization &amp; deoptimize, delay compilation of uncommon cases, tiered compilation &amp; on-stack replacement 等技术，在现代 JVM （甚至是所有的现代高级语言虚拟机）中都起着核心作用。 我希望各位在读完本文的节选和翻译后也能有相同的体会，那就是尽管这门语言早已死亡，但这却丝毫不影响语言本身和语言的设计者们的伟大——他们是真正对程序、对程序的可理解性和与现实世界的一致性保持高度关注和热诚的人们。如今，正如我在前一篇博文中提到的，计算机领域的抽象越来越高级，实现越来越复杂；编程语言本身包含越来越多的特性和抽象——这些抽象距离我们真实可感的现实世界越来越远、越来越远，我们要问，如今的编程语言是否早已偏离了它本应秉持的方向和价值？ 本文的标题一方面是引用自论文作者论文摘要（Abstract）的最后一句 Nevertheless, the vision we tried to capture in the unified whole has yet to be achieved. ，另一方面（更主要的）是在向 Alan Kay 著名的演讲 The computer revolution has NOT happened yet 致敬——Alan Kay 的这个演讲是编程语言顶会 OOPSLA 1997 年的keynote，被 Joe Armstrong 认为是 “80个计算机领域必学思想” 中的一个。 本文中提及的各种材料的出处和获取方式详见文末。译文附在原文之后。 正文 8. Conclusion Shall machines serve humanity, or shall humanity serve machines? People create artifacts that then turn around and reshape their creators. These artifacts include thought systems that can have profound effects, such as quantum mechanics, calculus, and the scientific method. In our own field thought systems with somewhat less profound effects might include FORTRAN and Excel. Some thought systems are themselves meta-thought systems; that is, they are ways of thinking followed when building other thought systems. Since they guide the construction of other thought systems, their impact can be especially great, and one must be especially careful when designing such meta-thought systems. We viewed Self as a meta-thought system that represented our best effort to create a system for computer programming. The story of its creation reveals our own ways of thinking and how other meta-thought systems shaped us [US87, SU95]. We kept the language simple, built a complicated virtual machine that would run programs efficiently even if they were well-factored, and built a user interface that harnessed people’s experience in dealing with the real word to off load conscious tasks to precognitive mental facilities. We did all of this in the hope that the experience of building software with the Self system would help people to unleash their own creative powers. However, we found ourselves trying to do this in a commercial environment. Free markets tend to favor giving customers what they want, and few customers could then (or even now) understand that they might want the sort of experience we were creating. Years later, the Self project remains the authors’ proudest professional accomplishment. We feel that Self brought new ideas to language, implementation, programming environment, and graphical interface design. The original paper [US87] has been cited over 500 times, and (as previously mentioned) received an award at the OOSPLA 2006 conference for among the three most influential conference papers published during OOPSLA’s first 11 years (1985 through 1996). Self shows how related principles can be combined to create a pure, productive, and fun experience for programmers and users. So, what happened? Why isn’t your word processor written in Self? While we have discussed the struggle of ideas that gave birth to Self, we have not addressed the complex of forces that lead to adoption (or not) of new technology. The implementation techniques were readily adopted, whereas semantic notions such as using prototypes, and many of the user interface ideas behind Morphic, were not so widely adopted. We believe that, despite the pragmatic reasons mentioned in section 6.1.5, this discrepancy can better be explained by the relative invisibility of the virtual machine. If there are dynamic compilation techniques going on underneath their program, most users are unlikely to know or care. But the user interface framework and the language semantics demand that our users think a certain way, and we failed to convince the world that our way to think might be better. Did our fault lie in trying to enable a creative spirit that we mistakenly thought lay nascent within everybody? Or are there economic implications to the use of dynamic languages that make them unrealistic? Many of us in the programming language research community secretly wonder if language research has become irrelevant to most of the world’s programmers, despite the obvious truth that in many ways, computers remain painful, opaque black boxes that at times seem intent on spreading new kinds of digital pestilence. Almost two decades after the conception of Self, the imbalance of power between man and machine seems little better. We are still waiting for computers to begin to live up to their full promise of being a truly malleable and creative medium. We earnestly hope that Self may inspire those who still seek to simplify programming and to bring it into coherence with the way most people think about the real world. 译文如下： 8. 结论 是机器服务于人类，还是人类服务于机器？人们创造了人造物，而它们又反过来重塑它们的创造者。这些人造物包括能产生深远影响的思想体系，如量子力学、微积分和科学方法。在计算机领域中，影响不那么深远的思想体系包括 FORTRAN 和 Excel；有些思想体系其实是元思想体系——也就是说，它们是构建其他思想体系时应该遵循的思维方式。由于它们指导着其他思想体系的构建，所以它们的影响尤其大，人们在设计这样的元思想体系时必须特别小心。 我们把 Self 看作一个元思想体系，它代表着我们为创造一个计算机编程系统所做的最大努力。创造 Self 的故事揭示了我们自己的思维方式，以及其他元思想体系是如何塑造我们的 [US87, SU95]。我们始终保持语言本身的简单，并实现了一个十分复杂的虚拟机，它能够十分高效地执行良好构造的程序；我们还建立了一个用户界面，利用人们处理真实世界的经验，将心智负担转化为对潜意识的利用（从而消除了心智负担）。我们所做这一切努力，是因为我们希望 Self 系统能够帮助人们释放自己的创造力。 然而，我们发现我们是试图在商业环境中做这件事情。自由市场的规则要求我们向客户提供他们想要的东西——然而在当时（甚至是现在），只有很少的客户才能认识到他们或许需要我们创造的那种体验。 近半个世纪过去，Self 项目仍然是作者们最为自豪的专业成就。我们坚信 Self 为语言设计和实现、编程环境和图形界面设计带来了启发。我们最初提出 Self 的那篇论文 [US87] 被引用了超过 500 次，在 OOSPLA 2006 会议上获得了历史最具影响力论文奖——这一奖项授予 OOPSLA 会议的头11年（1985年到1996年）间发表的前三篇最具影响力的论文。Self 展示了如何将相关原则结合起来，从而为程序员和用户创造一个纯粹的、高效的，以及有趣的体验。 那么，到底发生了什么？为什么你的文字处理器不是用 Self 写的？尽管我们已经讨论了催生出 Self 语言的种种思想斗争，但我们还没有讨论导致新技术被采纳（或不被采纳）的复杂力量。（正如 Self VM 的实现技术很快就广泛渗透到了当今世界上几乎所有的高级语言虚拟机中）实现技术很容易被采纳，而语义概念——如使用原型，以及 Morphic 背后的许多用户界面理念——却没有被广泛采纳。我们认为，尽管我们在 6.1.5 节中已经列举了种种实用性原因（如内存要求过高），这种差异或许可以用虚拟机的相对不可见性来更好地解释：我们编写的程序之下正在不可见地执行着动态编译，而大多数用户其实并不怎么了解或关心它们。但是，用户界面框架和编程语言语义却要求用户以某种特定的方式思考，而我们却未能说服世界，以我们提出的方式思考要更好些。我们是错在试图唤醒事实上并不存在于每个人心中的创新性精神吗？还是说使用动态语言有一些经济学意义上的影响，使之不切实际？我们，编程语言研究界的许多人们都在暗自怀疑，编程语言研究是否已经与世界上大多数的程序员无关——尽管显而易见的事实是，在许多方面，计算机仍然是痛苦的、不透明的黑盒子，它仍在传播新的数字瘟疫。 在 Self 的种种理念提出近20年后，人与机器之间的力量不平衡似乎并没有什么好转。我们仍在期待计算机开始实现使其自身成为真正可塑的创造性媒介的全部承诺。我们真诚地希望，Self 能够激励那些仍在努力寻求简化编程的方式，使之与大多数人思考现实世界的方式相一致的人们。 （编程语言的变革仍未到来。） 主要引述来源 David Ungar and Randall B. Smith. 2007. Self. In Proceedings of the third ACM SIGPLAN conference on History of programming languages (HOPL III). Association for Computing Machinery, New York, NY, USA, 9–1–9–50. DOI:https://doi.org/10.1145/1238844.1238853 Ray Eldath. 计算机领域的三个重要思想：抽象，分层和高阶. this blog. Alan Kay at OOPSLA 1997 - The computer revolution hasn’t happened yet. https://youtu.be/oKg1hTOQXoY GOTO 2018 • Computer Science - A Guide for the Perplexed • Joe Armstrong. https://youtu.be/rmueBVrLKcY","link":"/programming/self-language/"},{"title":"[译] 病毒学家内森·拉尔夫：我无比期待“最后一场瘟疫”","text":"本文是一篇旧文。最早是作为知乎的独立文章发出去的——果然没什么人感兴趣，这么久以来，现在咱也算是半退乎了。最近刚好又在选译、纯手译一篇巨震惊的文章（各位敬请期待），于是想着把以前这篇稍微改改放上来算了，估计反正也不会有人看的。 好吧，就这样。以下是旧文章内容。 本篇文章是刊登在非盈利机构 edge.org 上的英文访谈辑要的翻译。原文地址：WAITING FOR “THE FINAL PLAGUE” - edge.org。翻译经 Edge.org 编辑 Russell Weinberger 授权。 读完全文，我们不禁思考这样一个问题：如果这样一个世界，一个科学家有大得多的话语权的世界，一个人们都按如今科学家一而再再而三地呼吁、但又总是被一而再再而三地忽略的那些“应该”行事的世界，如果真的实现了，如果人们真的能活在那样的世界、那样的社会里，究竟是一幅什么景象？ 除了对这一次疫情的反思，我们还应当看到：不管情愿与否，我们都已经迎来了二十一世纪的第三个十年。在这个谣言横行、反智主义高涨的当今世界，在这个科学界早已定论的气候变暖都还被不断质疑、反疫苗运动声势浩大的当今世界，我们，普通民众、科学家、科普作家、政治家、所有人类，到底应该做些什么，才能建构更加美好的社会，才能避免人类自作自受的灭亡结局？ 以下是全文。其中“编者按”系原编者所加，“关于被采访者内森·沃尔夫” 请见文末。 【编者按】2009年一月，我在洛杉矶和病毒学家 Nathan Wolfe 就他关于病毒如何出现的生物学研究进行了一次深入广泛的讨论。在短短几个月内，2009年近乎全年持续爆发的 H1N1 猪流感病毒流行引起了世界范围内的恐慌。数月后，在《如何预防一次大流行》（本文未翻译，将跳转至 Edge.org 上原文。——译者注）这篇文章中，他写道： 这一次的猪流感爆发乍一看似乎是毫无预警地突然发生，在被注意到的数日内，就已经蔓延到了无法控制的地步。然而，这次爆发背后的病毒在被发现之前就已经存在好一阵了，莫非我们做不到更早检测、更早行动，抢在它如此大范围地蔓延之前就控制住它吗？答案似乎是否定的——如果我们一直密切关注可能导致新病毒出现的人-动物间相互作用的话，如此大范围的爆发，或许就不会发生。 尽管人们对这样一场大流行（pandemic）如何爆发仍知之甚少，对这种微生物，我们却相当熟悉：和SARS（严重急性呼吸系统综合征）、流感和HIV（人类免疫缺陷病毒）一样，它们都有大范围传播的风险。我们知道它们通常来自动物，特别是世界上一些特定地区的动物：比如刚果盆地和东南亚。 通过监测在这些病毒“热点区域”内接触动物的人们，我们能够在病毒进入人类种群的那一刻就捕获病毒，从而发展出预测、甚至可能是预防大流行的能力。 不幸的是，那次有11年历史的交谈，与今天更息息相关。以下我们与 Nathan Wolfe 再次讨论这一议题。 内森·拉尔夫：我无比期待“最后一场瘟疫”通常意义上讲，我感兴趣的，很大程度上是一个与我们自己的宇宙平行的生物宇宙，这个宇宙由各种微生物组成。我特别感兴趣的是病毒，但也有细菌（令人着迷的生物）和一系列寄生虫。 历史上，这些生物和我们一道出现，和我们共处共存，但却是栖息于一个截然不同的世界中：他们也会响应那些和我们也要相应的、完全相同的诸多压力，只是时间跨度要短得多；当然，它们也服从自然选择。对我们的星球而言，对作为这个星球上一个物种的我们而言，它们极其重要，然而事实却是我们对它们知之甚少。当下的情形其实相当有趣，考虑到我们当前拥有的技术，我将列举一些通过分子生物学得来的事实。 譬如说，我们掌握的宏基因组学（metagenomic）技术，可以让我们只需一滴水或一滴血浆，就能知道这些存在于这些液体、固体、土壤或粪便，或者是唾液中存在的核酸和生物的惊人多样性，无论你打算做什么。 对于一位生物学家来说，现在是一个迷人的时间点，因为我们不再需要培养这些生物中的每一种来鉴别它。我们可以更简单地理解这些微生物的遗传特性，这使得我们有了这样一种幸运：我们有幸回到过去，成为自然历史学家，去探索这些我们知之甚少的微生物的多样性。 这就是我的兴趣所在：我确实仅仅只是一位生物学家和一位自然历史学家，碰巧主要对微生物感兴趣——但是是在人类演化、哺乳动物多样性和生物地理学的语境下。我认为现在是一个美妙的时间节点，我们真的有幸回到过去，去探寻那些基本的发现。我们一直在发现新型的病毒——你不能“一直”发现新的灵长类动物，因为我们已经发现了其中的大多数，但对病毒来说绝非如此。 很明显，人们对有害的病毒有着极大的兴趣。我想指出的其中一点，也是首要的一点，那就是病毒有着如此之多的多样性：它们中大多数或许是中性的，它们中不少有重要的生态学意义，它们中有一些确实对它们的宿主有害。如前所述，人们对产生负面影响的病毒和微生物兴趣盎然，譬如能够导致1918年流感大流行（1918 flu pandemic，指的是1918年1月至1920年12月间爆发的全球性甲型H1N1流感疫情。这次大流行共造成5亿人感染、5千万到1亿人死亡，是人类历史上最致命的自然事件之一。——译者注）的病毒还有HIV病毒——SARS病毒也能够引发那样的大流行。这些都是有可能相对迅速地对人类人口造成破坏性影响的因素。 通常而言，看看全球范围内的疾病控制，你会发现其中的大多数都不由生物学家实施、亦非在科学的领域内施行，而实际上是以一种应用科学和医学的方式。公共卫生科学，实际上就是疾病控制：它等待着一次大流行的发生，然后尽一切所能竭尽全力地尝试控制住它。 但是，我们在分析那些重要的传染性疾病的过程中发现的一个事实就是，这些疾病大多都来源于动物。几乎所有这些重要疾病最初都是动物疾病，它们由于各种原因，经水、蚊子、血液，由猎人传染给人类。他们暴露于这些媒介，这些不断冒出病原体的媒介，那些暴露于这些媒介的个体，是恒常的桥梁，是病毒的桥梁。 这些事情大部分都不会有结果。在这些个体身上，它们几乎瞬间就会灭绝。即便它们开始在人与人之间传播，也就是开始具有潜在的重要性和危险性的时候，它们中的大部分也会灭绝，在当地人群中消亡殆尽。必须具备恰到好处的条件，才能有效地跳出当地人群——在这一点上，这些媒介并不完全适应人体——那些病毒之所以能够引发大流行，大都因为跨过了这一步。 然而，全球范围内的疾病控制只集中在极少数达到金字塔顶端但已在全球范围内传播的病毒上。想想HIV，1981年，就在加州大学洛杉矶分校（UCLA）的这条街上，第一批艾滋病病例被确定为一种综合征。但是，据估计，同年全球至少有十万人已经感染了艾滋病病毒，甚至可能不止十万。 所以，这已经错过了一个关键时期，一个本可以真正解决这一大流行病的关键时期。到那时，到1981年，已经为时已晚。毋庸置疑，这是一种非洲疾病，一种不知怎地传播到了加州大学洛杉矶分校医学中心（UCLA Medical Center）的人们身上的非洲病毒。那时甚至花了三年时间才找出导致艾滋病的病原体（HIV），美国总统花了七年时间才能够使用“艾滋病（AIDS）”一词。 现在，我要设想一个略微不同的场景。比方说，我们一直在更全面地研究人类和动物之间的这种相互作用，并试图主动地预测这些大流行病，我们就会知道中非存在一种被忽视的病毒；我们就会知道它在非洲通过千百种不同的途径传播，最常见的是通过异性性行为；我们就有可能诊断到：这将会是一场被忽视的热带疾病。当疫情真正发作的时候，比如就在这里，就在美国，我们将拥有巨大的领先优势。 钱生钱，利生利——这就是它的益处：就最终结果而言，每个月、每一年我们得到的这些流行病的早期预警，都有着巨大的收益。我们进入全球性流行的时代已经30年了——其实还不止，如果你从这些病毒真正传给人类开始算起的话，那大概是20世纪早期的某个时候。50或100年后，当人们回望这段历史，当人们回望当下这段历史，他们会发现某种程度上我们现在所做的，就是我们在50、60年代治疗心脏病时所做的：我们没有预防它，我们不是在测量胆固醇水平，我们不是在测量血压并控制吸烟，我们实际上是在等待一次心脏病发作。我们在等待一次全球性大流行，等待全球性大流行发作。 这样一种说我们本可以在预测和预防大流行上做得好得多的想法无疑是大胆的，但真正大胆的想法是，我们或许能到达这样一个临界点——遥远未来的一个临界点——在这个临界点上，我们是如此擅长预测和预防流行病，以至于出现了“最后的瘟疫”；我们能够捕获如此之多的病毒，以至于新的大流行变得相当奇怪：这是我们当然应有的一个理想。如果你问问从业于公共卫生领域的人们，他们甚至都不会想我们能够预防艾滋病，更别说我们能否到达一个临界点，再也没有任何瘟疫，亦无需总想着根除某种流行病。 根除，在今日的公共卫生领域只是理想。显然我们有疫苗：我不能坐在这里，作为一位病毒学家，对疫苗或根除病毒大放厥词。但是，另一方面这些都是非常被动的回应，无疑它们比感染后治疗更高效，但也比首先预防瘟疫发生要低效得多。 我正在寻求大量资源，用来在世界各地建立监测站，去真正监测那些高度暴露于野生动物个体，以发现这些病毒的桥梁，这些从动物到人类的病原体的活动，并通过它们来知道，首先，那里出现了什么。 这些正在流通的病原体具有怎样的多样性？你可以认为这是一种病毒群系、或微生物群系的多样性。那么，当下就在人类、和我们与之接触的动物中的微生物，又有着怎样的多样性？ 我们需要列一个清单，这样我们未来发现它们的时候，我们就能知道它们是什么。其次，当它们试图进入我们的空间的时候，我们能有预防系统，以便能捕获它们。这是一项特别昂贵的工作，但是，无论我们花费了多少，我们所做的，捕获的每一个病毒，都是整个系统立即产生的回报。对非典病毒来说，实际上最终也只约有1500到2000个个体感染，即使是这样一场流产的大流行，也会产生，据估计，数十亿美元的经济影响。这仅仅是一次短暂的、流产的大流行。确实，我的工作就是为了达到“最后的瘟疫”。 我达到这“最后的瘟疫”的方式就是，研究大流行是如何产生、如何消亡的；研究我们应该如何做，才能预测和预防这些大流行？ 在某种程度上，“最后的瘟疫”只是一种理想。回顾20世纪，你会发现那时、现在、未来，都有一座恒常的桥梁：每次走在威尼斯的海滩上，你都会看到有人在舔他们的狗（？）。我不是在说这是一种危险行为，但是这的确在交换微生物，这种交换不断地发生。微生物在个体和个体间持续转移，在物种内和物种间持续转移。 如前所述，这种交换中大多都不重要。但是，仍然，回顾20世纪，那时有一些病原体，其中的很多从未被捕获，它们就有着这种转移：从动物到人类，在世界范围内传播。这些病原体中有一些或许从未引发过可怕的疾病；还有一些或许和其它已知的疾病弄混，错认为就是它们；现在有一种全新的疟疾正在亚洲西南部蔓延，这是一种猕猴的疟疾，一种亚洲猴子的疟疾，被称为猴疟虫。 当公共卫生领域的人们真正诊断疟疾时，他们在显微镜下观察它们，并被迫将它们称作是人类四大寄生虫之一的寄生虫，所以这一切都被误诊了。你没法知道事实，除非你回过头来仔细研究。瞧，猴疟虫正在扩散，而且它刚刚被鉴定为另一种寄生虫，它是一种致命的动物疟疾寄生虫。 我甚至没法告诉你整个20世纪发生了多少次大流行，但是肯定不少。重点是，如果我们颇为擅长诊断这些病原体，我们可能就永远不会关注那些不引起疾病的微生物。比方说，每三到五个人中就有一个感染了一种叫做GBV（庚型肝炎）的病毒，这是一种传染性极高的病毒，但它不怎么会引发疾病，也许患病率稍低一些。但不管它是什么，它都是一种大流行病毒。谁在乎呢？ 有趣的是，在未来，这种病毒可能会具有某种重要性，但实际上，归根结底，我们只感兴趣那些会引发疾病的微生物。如果我们一开始就能够更好地预测和预防流行病，而不是仅仅专注于控制它们，那么随着时间的推移，新型流行病的发病率将逐世纪下降。我没有说我们能够轻松解决——“挺好，这就是最后一次瘟疫了”——但我们的目标绝不仅仅是根除业已存在的疾病，而且还应是根除那些还未出现的新型疾病。要达成这个目标还需要很长的时间，但我们也要改变我们的观念，视根除还未出现的新型疾病为目标，根除现有疾病，不应再是终极目标。 如果你想了解我的工作，一种方法是把我想作一个微生物收藏馆的馆长。我有些藏品颇丰的储藏库，我的专注于收集各种有趣微生物的站点遍及世界各地，我和各种不同的小组合作。我没有仔细查看我的收藏，而是将这些标本寄给那些我认为可能会对此感兴趣的研究者，他们研究这些标本以发现新的病原体。说真的，这挺像一个微生物博物馆。因此，我没在美国怎么待过。我的办公室比你的套房大不了多少，不怎么大，尽管我的事业维持起来非常昂贵，但对我来说四处走动没什么难的。 其实我并不亲自完成所有的实验室活儿。我所做的，更多是在世界范围内寻找专家，他们要不使用一些技术鉴别新型病原体，比如 Forest Rohwer（美国病毒学家，主要研究珊瑚礁微生物和病毒。——译者注，下同）、Joe Derisi（Joseph DeRisi，美国生物化学家，主要研究分子生物学、病毒学和计算生物学）和 Eric Delwart（美国病毒学家，主要研究分子病毒学、病毒进化和发病机理），要不研究特定的病原体种群，比如世界上最好的黄病毒学家（黄病毒科，该科共分为四个属，主要感染哺乳类动物），或者是分子寄生物学家。除了我在世界各地的田野实验室之外，我还有12个合作实验室，每个实验室都会收到我寄出的标本。 我的工作和艾滋病疫苗的研发形成了一种鲜明对比。HIV被发现时，卫生与公共服务部长（Secretary of Health and Human Services）口口声声地向我们承诺，一年内就会有针对HIV的疫苗。现在已经是三十年后了，不少组织已在研制艾滋病疫苗上花费了数十亿美元，这项投资的益处值得怀疑。 长话短说，研制疫苗真的很难。简单的疫苗事实上并不由人们研制，而只是被人们发现。牛痘，即天花疫苗：我们并没有对它做什么技术上的处理。我们今天所做的并不比当时巴斯德所做的复杂多少，仅仅是取一些牛痘病毒，取一点点，注射进手臂里。牛痘病毒和天花病毒密切相关，若一个人被这种病毒感染，就能产生抵抗下一次感染的免疫力。 我的事业之起步，是从我进入哈佛大学，师从于 Marc Hauser（Marc D. Hauser，美国进化生物学家，主要研究灵长类动物行为、动物认知和人类行为）和 Richard Wrangham（Richard Walter Wrangham，英国灵长类动物学家，主要研究猿的行为和人类进化）开始的，我是前者的第一位博士生。随后我对意识的演化产生了兴趣，进化使我着迷；高中时我就读了道金斯的《自私的基因》，并被其深深吸引，老实说这本书或许是我对生物学着迷的原因之一。我是带着对进化论和生态学的兴趣而非对机理（mechanism，致病机理？）的兴趣来研究的。我并不专注于机理，尽管有些时候我也要使用这些工具或者思索机理。 我在哈佛大学学习人类生物学。我开始和 Richard 一起工作，研究黑猩猩的自我治疗行为。Richard 鼓励我去了解黑猩猩可能在治疗什么，所以我开始思考什么是病毒，黑猩猩身上有什么微生物，它们可能因为这些微生物而吃植物。然后我就走上了这条道路，再也没有回头。 那时，我对阅读和思考意识的演变感到沮丧。我觉得这是一个飘忽不定的目标：人们一说“好吧，我们在这个物种身上找到了证据”，进度条就会发生变化…… 我离开了这个领域。这样的、让我捕捉到领域内令我感兴趣的问题的方法使我感到沮丧。随后是病毒——它们令人着迷，它们进化迅速。 我研究病毒是因为我研究黑猩猩的自我治疗行为，我开始研究黑猩猩的病毒。这是个非常有趣的故事，一个非常有趣的、关于艾滋病毒起源的故事，一个令人着迷的故事——那一刻它充满生机和活力，只是它还没有被完全理解。 不少人已经接近HIV的起源，但还没有真正理解它，甚至疟原虫也是如此。那时我开始对疟疾的起源感兴趣，为何这样一个对人口如此重要的生物，为何我们能对作为一种生物的疟原虫那错综复杂、令人痛苦的发展进程了解得如此透彻，但又对其来源几乎一无所知？ 我相信，这部分上是NIH（美国国立卫生研究院）一样的组织内的实验室科学中偏见的结果：这样的组织对重大问题不感兴趣。他们只感兴趣细小的问题。不过这并不是说若有良好的科学政策，这些对细小问题的兴趣有什么不妥。 对于我的工作，我乐于将这些对大流行病的研究当作是生物学的一个子集。我所关心的并不是学科界限，而是我需要生物学家来解决它。医师的偏见是很重的：医师似乎很可能是认为所有的病毒都是负面的那类人。如果整个领域在朝正确的方向发展，那么一个20年后、或者50年后的优秀病毒学家，就会像爬行动物学家一样，像一些研究蛇的人们一样，清楚地知道或许公众对毒蛇最感兴趣，但绝不自欺欺人地认为毒蛇在蛇类中占比显著，而且在分类群中有什么特别的重要性。这些都是自欺欺人的想法。 这另一种类的各类生物，病毒，它们有着重要的生态学意义，它们是迷人的生物。我们之所以会把病毒想作十恶不赦、百害而无一利的东西，是因为医师们都在盲人摸象：如果你专找负面的病毒，你当然就只能找到它们。医师们价值无穷、功德无量，但通常是在一些特定语境下。我们研究的是生物学现象，让生物学家来研究自然是再合适不过了。 我将对你坦诚相告：我会顺着我的才智漂流，并试图专注于发现我感兴趣的事物。不论出于何种原因，我现在对阻止下一场疟疾肆虐和理解疟疾从何而来更有兴趣；我并不专注于根除疟疾：有很多人在这么做，而且若想精通也是门大学问，只是我对此不感兴趣。 关于内森·沃尔夫：内森·沃尔夫（Nathan Wolfe）是斯坦福大学 Lorry I. Lokey 人类生物学客座教授，负责领导全球病毒预测计划。他主要通过结合分子病毒学、生态学、进化生物学和人类学方法，研究病毒出现的生物学。他曾被授予久负盛名的NIH先驱奖（NIH Director’s Pioneer Award）并被任命为世界经济论坛全球青年领袖（World Economic Forum’s Young Global Leaders）。他还名列《大众科学》评选的 “杰出十人”（Brilliant 10）和《滚石》杂志的 “百强变革推动者”（Top 100 Agents of Change），并且是《科学美国人》杂志编辑委员会和DARPA国防科学研究委员会成员。 以上是全部译文。文章中大部分“译者注”引自维基百科。文末”关于内森·拉尔夫“部分译自 Edge.org 原文，部分引自维基百科。 翻译：Ray Eldath，转载请注明。译者才疏学浅，对翻译亦不精通，若有错漏之处，还请不吝赐教。 safe harbor：文章不代表译者观点。若有翻译相关问题欢迎指正，但译者对原文观点不负责任。","link":"/science/nathan-wolfe/"},{"title":"计算机领域的三个重要思想：抽象，分层和高阶","text":"昨晚看了点比较有意思的东西，于是决定写一篇文章简单讲一下。 本文致力于概括我对计算机界三个重要思想的体会和认识。我希望做的并不是简单的百科全书式的列举（“A 体现了抽象思想；B 体现了分层思想…”），而是从这些思想中选取几个我个人较有体会（或者是我单纯觉得十分有趣）的侧面拿来细讲。这些侧面仅仅能覆盖这些思想应用范围中十分微小的一部分，它们并不是最有代表性的、亦非最为重要的——仅仅因为，我个人对这点侧面有些体会，或者我个人认为它比较有趣而已。 同样需要强调，和本博客大多数文章一样，本文个人意见色彩浓厚——本文并不客观，更绝不权威。 为方便行文，文中提到的大量引述来源不会标号、也不会在文中注明。关于攥写时参考的资料，请参见文末 “参考文献”。 有关抽象要从软件开发的所有指导性思想（或者说是哲学）中找到最容易想到、最广为人知的那一个，那必定是本节的主题：抽象。 这是一种重要的心智活动，它从具体的、实际的概念和经验中提炼出较不具体的、更加泛化的部分。在软件生产实践中我们无时无刻不在使用这一工具：我们从具体的类中提炼出接口；从实在的数据中提炼出数据结构、泛型和多态；从生动的现实场景中提炼出实体并为之命名（有时候相比提炼出抽象而言命名还要更加困难）。某种程度上，本文中提到的其它两点思想分层和高阶同样是抽象的一种形式，但是我个人认为将它们单独拎出来会有一些特别的指导性意义和方法论层面上的价值——关于这点在本文的其它部分中会再作说明。 关于纯粹的抽象这一点，我主要想特别谈谈数学抽象。众所周知，这一类概念在计算机界中有重要应用。 “数学抽象”长久以来（我不知道这是否是我个人的经验，我希望有和我一样有相同看法的朋友），我对编程语言理论 PLT总有一种现在看来是错误的认识，那就是以为抽象代数是 PLT 的先修课。一到两年前我（极其痛苦，现在看来却同时是相当无用地）啃过丘维声的《抽象代数讲义》；粗略且不完整地看过油管上 Bartosz Milewski 的猫论视频；曾认真阅读过有关 Scala 中 Cats 库的拆解，并自己实现了其中的很多抽象。 然而，现在看来，这些经历并未帮助我理解很多东西。知道了 Monad 的形式定义（pure 和 flatMap，同时 Monad 还是一个 Functor 因而具有 map）和 Moniod 的抽象定义（幺半群，指一个定义有二元运算的集合，它满足结合律，并且有单位元）并没有帮助我更好地理解程序的意义和结构。现在看来这些知识几乎是独立的小块——它们与我绝大部分的编程经验并没有联系起来，只有极少数的时候（比如现在要写博文了= =）才会想起来这点东西。 于是我开始思考，偏向工业的程序员们应该如何对待抽象概念（尤其是从数学界借用的）？学习这些抽象概念到底能不能（以及如何能）提升一般程序员、或者是计算机产业界对代码的理解和认识？学习这些抽象概念，我们是否能籍以此成为更好的程序员呢？ Dan Grossman 教授回复了这一问题——这位 Dan Grossman 大概是 PLT 学界（和教学界）的重要人物（某种程度上，因为我曾听过他在 Coursera 上的系列课程 Programming Languages），我简单翻译了我的提问和回复（经编辑）： Dr. Dan: （客套话略） I’m here to ask you a question that has confused me for a while. The story may be a bit long, and I’m genuinely sorry for that. Many of my friends have been devoted themselves to PLT for many years. And, as their friend, I noticed there is a deep connection between PLT and mathematics — especially those overwhelmingly perplexing and abstract subdisciplines, e.g. Abstract Algebra. As a programmer, I’ve also noticed that there’re many (and even more and more) articles are intended to introduce some algebraic concepts to programming, e.g. Monad, Functor. Most of these articles use some analogy like a box, funnel, to make them more understandable. One of my friends has the following comment on these articles: he said that the only way to truly understand abstraction, is through abstraction, and inaccurate analogy cannot help. He said that to effectively (or even usefully) learn these abstractions, you have to learn mathematics, not some rough material, all it has is analogies. This trend — perplexing words used to boast, perplexing explaining articles read to have nothing — is not good. Personally speaking, I think these abstract concepts are just not useful. Just knowing a Promise in JavaScript is a Monad per se, and Functor “is a box” could NOT help you being a better programmer. Using these words in your own library makes the newcomer feel uncomfortable. So, here’s my question: What’s your opinion towards these abstractions, many of them are quoted directly from abstract mathematics? Can learn these abstractions helping me be a better programmer? And if I just “know” them but not “understand” them in a more abstract manner (which is the Abstract Algebraic), can I still be a better programmer? Would you recommend a “Joe Coder” to learn or use these words during his career? Will you write some easy-to-read articles to make “Joe Coder” learn them by showing them bunches of analogies? As a personal answer I’d like to say that reading those articles, just “knowing” them won’t help you become a better programmer. And using those words in libraries makes things even worse. A programmer should be honored if and only if they use and write things technical superior, not something mathematical superior. And this is my question. I’m eagerly waiting for your reply, as I think your opinion could really help me being a better programmer, and should I learn these concepts, how can learning them help me (if it could). 我谨在此向您提出一个疑问，这个疑问困扰我已经有一阵了。故事大概会有些长，而我对此十分抱歉。我的很多朋友已经在 PLT 界摸爬滚打了多年，作为他们的朋友，我注意到 PLT 和数学——特别是那些（于我而言）尤其难搞和抽象的学科，比如抽象代数——有着深刻的联系；而作为一位程序员，我又注意到如今有很多（以及越来越多的）文章致力于将一些代数的概念引介到编程中，比如 Monad，比如 Functor；这些文章大多会使用一些类比，比如盒子 box，比如漏斗 funnel，来使这些概念更易理解。 我的一位朋友如此评论这些文章（如果我作了不确切的引用，我在此对他真诚地道歉）：他说真正理解抽象的唯一方式是通过抽象本身，而不是通过并不准确的类比。他说为了充分地（甚至是有用处地）学习这些抽象，你必须去学数学，而不是通过一些糊里糊涂的文章，它们除了类比还是类比。 这样的一种趋势——令人困惑的词语用来故弄玄虚，令人困惑的文章读来一无所有——并不好。就我而言，我认为这些抽象概念并不大有用。仅仅知道 JavaScript 里的 Promise 本质上是 Monad，而 Functor “是一个盒子 box” 并不能帮助你成为更好地程序员，而在你自己的库中使用这些词语只会让后来者觉得不舒服。 所以，这就是我的疑问： 您对于这些抽象——它们中的很多直接引用自抽象的数学分支，有什么看法？学习这些抽象能否帮助我们成为更好的程序员？如果仅仅只是 “知道” 它们但却未以一种更加抽象的视野（即抽象代数）“理解” 它们，我们是否仍然能成为更好的程序员呢？您是否会推荐一位 “大众程序员” 去学习或使用这些东西？ 我个人的回答是，阅读这些文章，仅仅 “知道” 它们并不能帮助你成为更好的程序员，而在库中使用这些词只会让现状恶化。一个程序员应该以（且只以）使用或编写了技术上更佳的东西为荣，而不是数学上更佳的东西。 所以这就是我的疑问，而我急切地期待着您的回复。我觉得您的意见可以帮助我成为更好的程序员，以及我是否应该学习这些概念，它们对我能有什么帮助（如果有的话）。 Have a nice day!Ray EldathGitHub: github.com/Ray-Eldath MyBlog: ray-eldath.me Dan 回复如下： Ray, These are good but unanswerable questions as it is easy to end up down the path of “what does it mean to learn or understand something” which is a question of consciousness well beyond my expertise. :) For my own worldview, I am a fairly die-hard “operational semantics” person which comes through in my teaching. I believe you can understand monads and functors for programming purposes in terms of how they compute – what the rules are for operation’s like a monad’s bind operator. Yes, there are algebraic laws that should be followed, but to understand “what code does” these are not necessary. Entities like monads are very abstract and general – it’s a concept that describes a broad set of programming patterns / data structures / libraries / APIs and the power is that this is a guiding principle for how to both design and use such abstractions. The connection to advanced mathematics has value and helped develop these powerful abstractions, but it is not my view that effective programmers need to understand the full connection. Others will, naturally, vehemently disagree. :-) 这些都是很好的问题，但我无法回答，因为很容易就会走上 “学习或理解某件事情意味着什么” 的道路，而这是一个意识问题，远远超出了我的专业知识 :)。对于我自己而言，我相当顽固地秉持着 “操作语义”，这一点在我的教学中得到了体现。我相信你可以通过 Monad 和 Functor 在编程目的下的计算方式来理解它们——像是 Monad 的 bind 操作符受制于什么规则。是的，有一些代数法则是应被遵循的，但要理解 “哪些代码遵循它们” 并不是必须的。像 Monad 这样的概念是非常抽象和通用的：它是一个描述了一套广泛的编程模式、数据结构、库和 API 的概念，其强大之处在于它们是对如何设计和使用这种抽象的指导原则。与高级数学的联系是有价值的，并且有助于发展这些强大的抽象，但我认为成为高效的程序员并不需要理解全部的联系。其他人自然会强烈反对 :-)。 Best,Dan 我将对这些文字的解读留给读者。 &nbsp; 尤里卡！&nbsp; 提示 EDIT 2024/4/7：如 Dan Grossman 教授所言，如今我进一步地认为讨论这个问题没有什么意义。如果我有机会删去这一节，我会这么做的（显然，我认为事到如今再更动标题比留下本节更愚蠢）。当然，我一如既往地反对在任何一般文档和讨论中故弄玄虚地强行引用 Monad、Monoid 等概念的行为，正如 Haskell 主要作者 SPJ 曾在一个著名演讲中说他们最大的错误（“Our biggest mistake”）就是起了 Monad 这个名字 [1]；我还需要指出，作为理论计算机科学的重要部分，编程语言理论（PLT）是一项艰深的理论学问，对各种编程语言、解析器和编译器的了解与该领域既无关系、亦无明显益处。 对作为编程语言理论的基础知识即代数和拓扑（更广泛地，代数和几何间相互冲突又密不可分的关联）感兴趣的读者，我并不推荐丘维声的《抽象代数讲义》，而是推荐 John Stillwell 教授的 Mathematics and Its History (Third Edition)，该书中译本《数学及其历史（第三版）》由高等教育出版社于2022年出版，不要被它的名字骗了，这不是一本数学史科普 :)&nbsp;&nbsp; 对具体的 PLT 理论感兴趣的读者，请参阅 Practical Foundations for Programming Languages（该书需要对逻辑和归纳法有一定的熟练度）。 [1]：“So, workflow, I now think would be a much better name. A warm, fuzzy thing would have been good. Monad does sound rather scary, but it has the effect of filtering out people who want to learn Haskell, so that's good.（众人笑）” YouTube 源视频；转译稿（由 Anthony Hoo 提供，博主在此表示感谢） 有关分层相比抽象侧重于一种心智活动（从特化的到泛化的，从具体的到笼统的）、强调一种 “抽取” 的动作，分层要更加客观，它强调概念之间存在明显的、更加客观的断层，这些断层，或者说是界面，或者说是接口，区隔了层与层，提出了表面的接口 / 契约和深入的实现细节间的差别：上一层只需要依赖下一层的接口而非更加细致的实现细节，这意味着在良好实现的分层机制中，对于某一层的实现者而言，下一层的绝大部分是不需关心的。 但是，真的如此吗？ 抽象和分层向我们一再承诺的 “接口远大于实现细节”、“只需要关心很小的一部分”，在多大程度上是成立的？这样的封装有没有被打破的时候？ “Hyrum’s Law”最早听闻 Hyrum’s Law 是在 YouTube 的一个非常著名（评价也非常好）的talk A Philosophy of Software Design 里。主讲 John Ousterhout 讲到一半时主持从在线论坛里边抽了个问题问他，其中就提到了这个 Hyrum’s Law。 John Ousterhout 当时还愣了一下问啥事 Hyrum’s Law，主持把这个东西的简明定义说了一下，然后附了一句 “actually I Googled this” wwww 看来大家都不是很知道这个东西 😉 这个 Hyrum’s Law 的简明定义其实很好理解： Hyrum’s Law: With a sufficient number of users of an API, it does not matter what you promise in the contract: all observable behaviors of your system will be depended on by somebody. Hyrum’s Law: 只要一个 API 有足够的用户，那么无论你在接口契约中承诺什么，你的系统的所有可观测行为都会被某个用户所依赖。 更容易理解的或许是下边这张 xkcd 的漫画： Hyrum’s Law（又作 The Law of Leaky Abstractions）描述的是这样一种现象： 层被创造出来的本意是通过分层这一过程，从而界定一个清晰、明确的边界。这一边界划定了接口 / 契约和实现细节之间的界限，从而一方面提高了程序员的工作效率（“我只要用它就好啦”），另一方面——更为重要的是——降低了程序员的门槛，并减轻学习负担（“既然只要用就好了，那我应该就不用关心底层的实现细节了吧？”） 然而，随着一个层的用户逐渐增多，层逐渐失去了区隔契约和实现细节的作用：层的每一个可观测行为（不管是不是在契约框定的范围之内）都会被某些用户所依赖，这意味着分层的初衷事实上已不再有效：总有一个时候，我们的输入会足够特殊，我们的场景会足够复杂，以致于我们会依赖层的某一个契约之外的可观测行为。这个时候，层对我们而言已经毫无意义：我们依赖的早已不是层创设出的接口 / 契约，而是层的实现细节本身。 这样的例子数不胜数。比如，说到分层，大家脑海中的第一个想法，很可能会是计算机网络以及深入人心的OSI七层模型。 众所周知，TCP 承诺可靠、有序、无差错的数据传输。然而，有一天你突然发现服务器组中的某两台之间的基于 TCP 长连接突然变得极慢。你调试了半天，排除了所有的应用程序导致的元素，你终于把视线移到了 TCP 本身。 这时候你被迫去学习有关 TCP 实现细节的知识，你了解到网络中其它未部署端到端拥塞控制算法的协议（比如 UDP）很可能会严重影响 TCP 协议的工作（这些协议被称作是 TCP-unfriendly 的），你啃了啃几篇论文，终于了解到工作在 FCFS（First Come First Serve，先到者先处理）状态下的路由器处理 TCP – 无拥塞控制算法协议 的混合网络有各种各样的问题，典型的比如 unfairness，还有 congestion collapse——后者的效果甚至会导致在网络的送达率没有任何提升的同时仍然（毫无意义地）大大降低 TCP 的工作效率。你最终认识到在路由器上部署 WRR（weighted round-robin，带权重的轮询选择）算法或许是一个解决方案。 这时候，TCP 作为一个层，它原本承诺的减轻程序员学习负担这一效果完全没有体现：网络的异常逼迫我们去学习有关 TCP 实现细节的知识，这些知识完全没有包括在 TCP 提供可靠、无差错的数据传输 这一契约中。 这样的例子还有很多。比如，遍历二维数组时按行遍历和按列遍历之间的性能差异甚至意味着程序员最终需要打破语言虚拟机、甚至是 CPU缓存层级结构 的抽象。 软件业的至理名言 “没有银弹” 相信每位读者都听过，而分层作为一种抽象机制同样如此：它承诺的既能提高效率又能减轻负担的 “银弹般” 的作用，是不成立的。抽象带来的效率提升，是以更大的学习负担（对实现细节的学习）为代价的：随着我们创造越来越多、越来越高层的抽象，编程实现会变得更加简单，但成为专业程序员也越来越难。 有关高阶相比上一节强调物理或逻辑上客观存在的 “界限”，本节主要强调一种心智活动。这样的心智活动具有一个明显的特征，那就是它具有一种 “递归” 的结构。我们首先从一个概念中抽象出它的形成过程，再将这样的思维过程应用于这个概念自身。如此，我们得到的新概念常常具有这样的结构： A 的 A 。 个人认为，本节讨论的思想或许是本文的所有思想中最为重要的那一个。这是因为高阶这一思想具有很好的方法论层面上的指导意义，并且在实践中操作起来又有趣又直截了当——同时，个人的看法是通过这一思想生成的很多概念对启迪编程初学者的思维具有非常重要的意义（事实上，如果要从整个技术界中选一个本科教育一般不大重视、但又极度有价值的术语，我会选闭包和高阶函数）。 通过这样一种 “递归式” 的抽象过程得到的 A 的 A 这一形式的概念，我们通常将其称作 “高阶 A”。比如，将函数代表的过程（A -&gt; B）抽象出来，再应用于函数自身，我们就得到了 函数的函数，即 高阶函数 higher-order function。个人认为高阶函数和闭包是计算机领域最为重要的抽象之一。 比如，将类型的形成过程（类型描述一个语言中最小单位的类别）抽象出来，应用于类型自身，我们就得到了 类型的类型，即 型别 kind 。 最后，作为压轴，讲一个我昨晚在一篇屯了半年一年的文章中看到的一个概念。我想这个概念应该是超出大部分读者的经验的，而我觉得它还蛮有意思，所以放到最后来大概说说。我们需要从故事的最开始讲起——可能要过很久才能最终看到这个词。 “二村映射 Futamura projections”我们知道大体上编译技术可以分为两种，分别是 编译器 compiler 和 解释器 interpreter。编译器执行的是一个两阶段的过程：首先，自源代码编译出目标程序 target program，再向目标程序提供输入，然后得到程序的输出；解释器执行的则是一个一阶段的过程：解释器接收源代码和输入，并直接得到程序的输出。在本节中，我们主要关注解释器。 绝大部分的编译原理教科书和课程都只涵盖这两者。然而，事实上还存在着第三种编译技术：某种程度上，它介于解释器和编译器之间，但它既不是解释器又不是编译器——请特别注意这一点。为了方便理解，我先岔开点讲。 稍有函数式经验的读者应该都听过 柯里化 curried。如果有一个接收 $n$ 个输入的函数，我们可以把它转化成一叠嵌套的高阶函数，这叠高阶函数中的第 $i$ 个接收原函数中的第 $i$ 个输入（仅一个），然后返回接收剩下 $ n - i $ 个输入的函数（故为 “高阶函数”）：比如，一个接收 3 个输入的函数（(A, B, C) -&gt; Output）经柯里化后会成为一叠高阶函数，这个高阶函数中的第一个接收一个输入 A，然后返回一个接收输入 B 的高阶函数；再向其提供输入 C，才能得到最终结果，即柯里化后的结果是 A -&gt; (B -&gt; (C -&gt; Output))。 尽管在支持闭包和高阶函数的语言中柯里化和 反柯里化 uncurring 都能以非常浅显（trivial）的方式实现，但仅有少数的编程语言才一等地支持了柯里化，比如 ML系语言（Haskell, SML, OCaml, F#）和 Scala。 对于一个经柯里化后的函数，如果我们只向它提供前 $i\\space\\space(i&lt;n)$ 个输入，那么我们必然得不到最终的输出，而只能得到一个高阶函数，它会再处理余下的输入：这称作 部分应用 partial applied。 讲了这么一大堆，其实主要就是为了部分应用这个概念。你可能会想知道为什么我在上文不用参数这个惯用说法而是用输入，你可能也已经猜到了，这是因为我希望在此强调将解释器理解成一个函数的思想：它的输入是源代码和这段代码的输入，它的输出是这段代码的输出（事实上，很多语言都提供一些十分类似解释器的机制，它们确实是函数（比如 eval））。 是的，之所以要将解释器理解成一个函数，是因为我正是要借用部分应用的思想：既然解释器的输入是源代码和输入，那么我能不能部分应用这个 “函数”（即解释器），首先给定源代码，得到一个 “处理剩下参数的高阶函数”（即一个中间程序），然后对于这个中间程序，再提供它的输入，然后得到结果？ 答案是，这是可行的。事实上，这一过程称作 部分求值 partial evaluate，而执行这一过程的程序我们称作 部分求值器 partial evaluator。部分求值器作用于一个程序和它的一些参数，输出一个该程序对于这组参数 “特化” 后的新的程序。这里的 “一个程序” 我们称作 源程序 source program，“新的程序” 我们称作 残差程序 residual program。 回到上边有关解释器举例上来。我们将一个解释器和一个源程序传入部分求值器中，得到的残差程序就是一个接收 输入 返回 输出 的中间程序。 是不是觉得非常的熟悉……？第一阶段我们提供源代码，得到中间程序；第二阶段我们提供输入，随后得到输出。这是在做什么…？ 是的，这就是编译。神奇之处在于，我们并没有手工编写一个编译器，我们只是将一个解释器和需要被求值的源代码扔给了部分求值器而已——某种意义上来说，我们是 “免费” 得到了一个编译器。 你可能在思考这有什么用？你或许已经将这一思路和语言虚拟机联系了起来：众所周知，实现编译器通常比实现解释器难得多，那我们能不能弄一个本质其实是一个部分求值器的语言虚拟机，在这个虚拟机上实现一门新的语言只需要编写一个解释器就行了，而语言虚拟机会调用它的部分求值器自动帮我生成对应的、更加高效的 “编译器” 呢？ 显然，这是完全可行的——事实上这是有产业实践的。PyPy 是一个 Python 语言的解释器实现，它正是基于以上语言虚拟机的思路实现的：在 PyPy VM 上工作的语言有 Python, Ruby 和 逻辑编程语言 Prolog 等；除此以外，泛语言高级语言虚拟机（HLLVM）GraalVM 的一个重要组件同样如此，工作在 GraalVM 上的语言包括 JavaScript, Ruby, Python, Java, R 等。 这其实就是 第一类二村映射 first Futamura projection。 既然是放在 “高阶” 这一主题下的，我们当然要用到这一思想：正如前几段的粗体所提示的，部分求值器其实也是一个程序，它自身也能够被部分求值。 回想一开始，解释器 的输入是 源代码 和 输入，我们将 解释器（主体）和 源代码（主体的其中一个输入）单独拎出来，扔进了部分求值器中，这是第一类二村映射；即是说，在第一类二村映射中，部分求值器 的输入是 解释器 和 源代码。 我们将这一过程——即 “将 主体 和 主体的其中一个输入 单独拎出来扔进部分求值器中”—— “高阶化”，作用于自身，简单的代换就能得到，我们需要将 部分求值器（主体）和 解释器 （主体的其中一个输入）扔进一个部分求值器中。现在我们需要弄清楚，这个 “高阶过程” 得到的残差程序是什么。 注意到，在第一类二村映射中输入只有 解释器 和 源代码。既然我们已经部分求值了前者，那么下一步自然只剩下后者了：向上一段提到的 残差程序 提供 源代码，我们就能得到 目标程序。 向一个程序提供源代码得到另一个程序…… 听起来有点像是某个我们已经知道的东西会做的事情。是的，这就是编译。我们的这个 “高阶过程” 得到的残差程序其实是一个编译器，而我们的这个 “高阶过程” 所做的，正是在生成编译器，即，这一过程其实是编译器的编译器——如此，我们终于见到了本节概述中提到的 A 的 A 这样的结构，如果你愿意的话，或许你还可以将这称作高阶编译器。 这其实就是 第二类二村映射 second Futamura projection。 那么，这个 “高阶化” 的过程还能继续下去吗？显然如此。再继续下去，我们就能得到编译器的编译器的编译器，也即第三类二村映射 third Futamura projection。再往后呢？这点就留给读者自行阅读和思考啦。 参考文献本节提出的参考文献是本文中各种举例的来源。如果你想深入了解某一个方向或某一点例证，这些参考文献是最好最好的材料——我认为，它们无论是在哪个方面都要远远高于本文粗略而又空泛的简单说明。特别推荐的材料以 ⭐ 标注。 本节中列出的参考文献是粗略按照在文中的顺序排列的。 Stroustrup, Bjarne. “Evolving a language in and for the real world: C++ 1991-2006.” Proceedings of the third ACM SIGPLAN conference on History of programming languages. 2007. Dan Grossman. Private communication. Hyrum’s Law. https://www.hyrumslaw.com/ ⭐The Law of Leaky Abstractions. Joel Spolsky. https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/ ⭐A Philosophy of Software Design | John Ousterhout | Talks at Google. https://youtu.be/bmSAYlu0NcY Floyd, Sally, and Kevin Fall. “Promoting the use of end-to-end congestion control in the Internet.” IEEE/ACM Transactions on networking 7.4 (1999): 458-472. Würthinger, Thomas, et al. “One VM to rule them all.” Proceedings of the 2013 ACM international symposium on New ideas, new paradigms, and reflections on programming &amp; software. 2013. ⭐RubyConf 2013 - Compilers for Free by Tom Stuart. https://youtu.be/n_k6O50Nd-4 Perugini, Saverio &amp; Williams, Brandon. (2017). Revisiting the Futamura Projections: A Diagrammatic Approach. Theoretical and Applied Informatics. 28. 15-32. 10.20904/284015. lyzh 聚聚. Private communication. Robert Glück. 2009. Is there a fourth Futamura projection? In Proceedings of the 2009 ACM SIGPLAN workshop on Partial evaluation and program manipulation (PEPM ‘09). Association for Computing Machinery, New York, NY, USA, 51–60. DOI:https://doi.org/10.1145/1480945.1480954","link":"/programming/three-important-ideas/"},{"title":"记忆、目光、另一种迷惘：the end of 2021","text":"和这里的许多文章一样，本文的标题依然是仿照了某篇令我印象深刻的文章的标题。：-） 最近考完试就在忙课设，这两天才终于有时间把这篇文章写完… 「时间之矢向前飞逝 / 祂飞离时震颤的双翼总拍伤我的灵魂」，几个月前读到的这句诗如今无论是它的作者（是里尔克吗？）还是其全貌都已无从知晓，只觉得以这句想象力奇绝的诗句概括行将结束的整整一年，确实恰如其分。 写下上一篇年终总结（不知为何我很不喜欢「年终总结」这个词——如你所见，标题很努力地做到了不用这四个字）至今已有一年有余，而 2021 这一年，可以说是空前的烂漫和精彩。这一年，无数美好的事情，以我此前从来不敢想望的方式，完全不可预料地扑面而来（未来像盛夏的大雨，在我们还不及撑开伞时就扑面而来1）：今年的许多许多段回忆都是出奇的美好，它们是如此的弥足珍贵，冥冥之中我总觉得，即便是以一个人整整一生的时间尺度来衡量，这些回忆都将在时间的长河中熠熠生辉，就像华兹华斯笔下那些总能「让我们在困顿之时为之一振」的「卓越超群、瑰伟壮丽的若干时间点」2。 可是，正当世界向我们显露它那丰富多彩的衬里的同时，祂却又向我们徐徐展开了一副人们受苦受难图景的画卷。大三上已经结束，大家突然都紧张了起来，似乎才刚品尝到青春这甘醇甜美的琼浆，就要去体会人们这毫无意义地辛苦劳作、不得休息的无望图景。人们出于经济富足、出人头地等种种平凡低微的原因，在日常生活中从事各个琐碎、侮辱人才能又耗费人精神的工作，无论是不是心甘情愿，都要在就在这无尽的琐事中逐渐被「磨损」，逐渐只觉得，生活，永远在触不可及的地方，因为「此时此刻」永远是那么的无聊、那么的缺乏诗意、那么的死气沉沉——生活永远不在这里，因为生活永远在别处。 这是另一种迷惘。人总要在不断的学习中成长，可是只有很少的人能够对一个领域怀有足够纯洁的热诚，从而主动地学习并自得其乐；任何成就的取得都需要决绝的努力，可是人们很难为一个虚无缥缈、触不可及的目标和「理想」长久地坚持，并摒弃种种安逸的生活方式。时日无多，回首你这过去的日子，几乎都在随性而为的自由和放纵中度过，你是否已经失去了（甚至是从未拥有过？）沉着刻苦的品格？考研还是工作？你能坚持下去吗？曾以为坦荡无比的生活最终坍缩（是的，在目光的观测下）成区区几个选择而已，怎样做你才不会后悔？在被抛入 “就像海洋的生活”（广东孩子请会意地笑笑）之前，你还要做些什么？你到底想要怎样的生活，又到底是否有相称的品格和毅力来得到它？ 我依然没有答案。或者确切的说，自从一个月前学期仿佛是毫无预兆地结束以来，我一直在逃避这些问题，因为我实在是无从回答。我只希望当我完成本文，为这飞快过去的 2021 做完注时，我能有一丁点儿的头绪。 &nbsp; 关于头图 头图摄于 2020 年 12 月，是我们乐队在学校一年一度的音乐节演出前最后一次排练。那次排练效果很好，大家都非常高兴，那晚就是这美好、珍贵回忆中的一段。图中两人未出镜：我（因为这张照片是我拍的）和我们的贝斯手（我真的没有黑贝斯——至少当时没有！）。 &nbsp;&nbsp;本文中所有照片均经过裁切和压缩以加快页面加载速度——各位看个意思就好。 PingCAP，人生第一份工作比起技术上、特别是世俗意义上的种种成就，我更希望自己是一个丰富的人。当然你可能会说这是因为除了这所谓的「丰富性」之外我并没有任何足够突出的成就——在这点上你大抵是对的。无论如何，我并不打算将技术内容作为本文唯一、甚至大概都不是显要的部分；这并不是说技术内容于我是不重要的——相反，它们占据了我（这因你而火热 XD）的生活的大部分时间——只是对技术进步的「年终总结」难免囿于乏味刻板的机械罗列；再者，本文还有许多其它内容。 不过今年，在工作这个维度上，我翻开了新的篇章，那就是成为了无奈的打工人：-|&nbsp; &nbsp;约莫清明节前后，在大二下刚开始时，我决定将一直以来找实习的想法付诸实践。只投了腾讯和 PingCAP，顺利加入了 PingCAP 的 QA 组。 现在想来，当时能进贵司大概只是侥幸罢了；总觉得即便是再来一次，我可能在简历关就会被挂掉：-| 。加入贵司后不久就经历了一次组织架构调整，我换到了隔壁组，想着暑假要好好体验一下广州这座城市，又把 base 地从深圳换到了广州。 实话实说，我对工作内容并不是特别感兴趣，不过主要原因应该是上学期的我对自己大概喜欢什么还完全没有想法，所以这其实还是一段很棒的体验。mentor 和 leader 都对我特别好，他们问我体验如何，我回答道「我不会期望任何一家别的公司，能给我比 PingCAP 还好的实习体验」。每天都在感谢公司没有开除我：-） 这段经历还有一段特别之处，那就是暑假（七八月份）是在广州 office 度过的——一直以来，这都是我最喜欢的城市，我终于有了机会能好好感受她。 第一次乘拥挤的写字楼高速电梯上下班，体验有些奇妙，仿佛我的年龄和阅历都还完全不能接受我居然就这样成为了这社会朴素又低微的螺丝钉，脑海里的千万个宏图展志永远都不得实现而心有不甘；又仿佛这冷漠茫然的白领人群和直上直下的高速电梯与学校课堂、食堂、寝室「三点一线」的规律生活之间的反差实在是有点太大了，大到了让人有些庞然无措的地步。 适应之后，在 office 上班的两个月，总体还是非常舒适的。有熟悉的学长一同摸鱼、卷 CS，总归还是不会那么枯燥乏味（&nbsp;&nbsp; 住处干净整洁，楼下就是购物中心和小吃街，离公司也只有一个地下通道的距离；俯瞰整个琶洲的江景高层公寓低廉的价格使我对广州的好感更上一层。 每天下班，先是沿着江边散步到琶洲大桥，再坐我经常形容为 “非常温柔地” 发出「铛、铛、铛」声音的有轨列车回到住处；点一份外卖（附近有一家不错的粥铺），晚上就在这开阔的景色前读书；每每感到疲乏劳累，抬头向外望去，横向伸展的街灯和缓缓驶过的车流总能让我感到轻松和宁静，于是又埋下头来尝试消化 B4（顺带一提，这篇论文十分值得一读！） 中有关流量工程的诸多细节。 周末则是在只消几站地铁（当然，我更喜欢坐电车）就到的珠江新城消磨时间，博物馆、美术馆、音乐厅，在图书馆的东欧文学区流连一阵，晚上准时打卡海心沙喷泉，再慢悠悠地散步走回住处。即便是看了不知多少次，每一次站在海心沙亚运公园的喷泉池前，在广州塔不断变幻的灯光下，看着升高的水柱逐渐超过远处猎德大桥顶端挂着的四个红色的发光大字，我还是会感到一丝兴奋——仿佛这随着吹拂的微风四处飘散的水珠，就是那五羊传说中衔着稻穗的仙羊，为世界降下的象征着幸福的甘霖。 然而谁能料到，仅仅半年后就迎来了互联网产业的又一次寒冬，公司方向的调整使我成为了整个研发部门最后一个日常实习的 offer。随着远程实习变成短暂记忆里渐渐消失的回响，我也从三语播报城市回到了双语播报城市。 技术，路在何方今年技术的最大成长，或许是知道了自己应该努力的方向。接下来我要作一些枯燥无味的机械列举了——希望读者能够包容这点。 年初修完了 Dan Grossman 教授在 Coursera 上的编程语言课程 Programming Languages 的所有部分。 稍微认真一些地看了一些 PL 的内容（一点 HOPL（HOPL 上的文章都好长… 至少 60 页…）、一点 LLVM、一点零散文献）（我自知自己还完全配不上 PLT 这个术语中的 T 字母——我会继续努力的），主要是一些奇奇怪怪的文章，在本博客有一些相关的想法。自己对这个主题的了解实在还是太少了，并不具有卖弄的资本，还有许多要读的文章和书籍。希望 2022 能修完两门打算了很久的网课。 读完了《自顶向下》和一些网络方面的文献，跟着 CCNA 的实验手册在 GNS3 上体验了一把网管… 不得不说，《自顶向下》的参考文献列表真的十分有价值。 因为工作的原因看了一些 Golang、gc 和 Go 语言设计与实现，感觉好细节… 目前就记得 channel 的 handoff 和 L4 里处理 IPC 的方式有一些异曲同工之妙… 看了一些公司的数据库相关的资料和 CMU 15-445/645，然而完成了前两个 lab 就跑路了… 可能自己确实不太喜欢存储。或许 2022 再试试？ 大三上修完了 MIT 6.S081 的所有课程和 Lab，后半部分的论文阅读使我十分兴奋，于是跟着 ACM Digital Library 上几个会议的 Top Cited 又读了一些比较著名的文章（除了 monokernel、μkernel、unikernel，还有前两天刚读到的 multikernel… 操作系统领域内的各种令人好奇的问题和机制层出不穷，或许这就是我应该努力的方向？）。从这起读的文章就多了很多，似乎终于得以一瞥「严谨的计算机科学」的剪影。 Tanenbaum 教授的《现代操作系统》太好看了！在修完 MIT 6.S081 这类实践性很强的课程后，MOS 这本书能使你对操作系统领域的许多并未在课程中覆盖的解决方案以及各个细节组件形成的复杂、动态的整体产生深刻的理解——更别提这本书还十分幽默！这里还要感谢译者们相当出色的翻译水平，个人认为本书的翻译甚至比《自顶向下》还要好些。 终于完成了 astrio 这个在许多好些的大学都只不过是本科生必修课的五级流水线 MIPS CPU… 正如 repo 的提交历史反映的，这个项目的主体部分是我于 2020 年一个在家学习的清闲学期完成的，当时主要使用 Verilator。后来本学期刚好有计组课，我找老师借了 FPGA 开发板（似乎整个学校都没什么人会用这玩意，又只能纯靠自己折腾 = =），修复了两年前冥思苦想许久也未能解决的众多 bug，成功将这个小玩具上板测试，才算终于完成了这个项目。 我想调试这个项目和 MIT 6.S081 lab（这两个项目都非常难调）的最重要收获是教会了我一种为陌生的体系构建系统的方式，这种 “一点一点来” 方式十分有效，至少就修复这两个项目中数不清的难搞 bug 而言。 大三上的课业出人意料地顺当。计组、嵌入式、操作系统、专业英语，四门大专业课都十分有幸遇到了非常棒的教授，实验没花太多时间就拿到了前列的成绩，考试也从未如此简单。希望这几门课能有一个好的总分。 似乎终于明白了「通过兴趣提升语言词汇量」是什么含义。每天一到两集 NPR 听力，最喜欢 Up First、Consider This 和 Short Wave；硬着头皮读塞林格，尽管生词很多，但伴着词典，塞林格流畅的笔触和出人意料的结局每每使我情不自禁地跟着朗读。习惯了之后，这样的方式比背单词真是要舒服太多，「停滞已久的时钟终于又转了起来」（忘了在哪看到这句话的了…）。 剩下的时间都给了工作，还有各种零零散散的阅读（内存序云云，Kubernetes 云云…）。「通过一门顶尖的大学课程或者是教科书才能了解一个领域」，这个道理我明白得实在是太晚了。真希望自己有更多时间。 每年完成的事情，总结下来似乎都是那么少、那么地少于自己的期望。空闲的时间由疲惫、自我怀疑和焦虑填满，在 极限竞速：地平线（这是我目前最喜欢的游戏——我的机箱上就刻着这个游戏的图标）、Beat Saber 和 Haven 里消磨时间，总是思忖这无从下手的未来，在反复的失眠中变得易怒又焦躁。自己没有足够的热忱、越来越没动力写代码、又不甘将技术理解为「无奈的生计」，时日已无多，矛盾又懒惰的我，到底路在何方？ 不过地五是真的好玩！越玩越觉得比地四好玩。 乐队，自由的音符或许今年最大的收获，就是自己的乐队终于迈上正轨了。从大二下学期偶然组建（当时的情形是一位学长（另一支乐队的节奏吉他手，我们两支乐队如今关系十分紧密）花二十分钟劝说另一位吉他手改玩贝斯（他的原话是：你如果玩吉他，那你充其量就是个吉他手而已；可你如果改玩贝斯，你就成就了一个乐队），于是他就成就了我们乐队），途中因为技术和时间安排的原因遇到各种波折，到现在大家众心成城、也明确地知道「下一首歌」应该是什么效果、又该如何处理各种乐器之间复杂的关联与冲突，我们作为一个乐队的整体成长很大。于我个人而言，更重要的是我认识了这样一群人：大家接纳、关心彼此，有共同的目标和愿景，能够一齐欢笑一齐悲伤——这对我而言，还是一种新鲜的体验。乐队的成就属于它的每一个乐手，每一次选歌时的争执、排练时我和吉他手总要停下来互问对方如何处理这一段节奏抑或是那一段和弦、从以前演出前总是紧张到现在即便是在台上也无比轻松因为我知道我们就是能取得我们希望的效果（尽管不够完美）：是乐器将我们连在了一起，我们知道我们并不想仅仅是简单地 cover 一首歌，而是要把我们的理解融入对每一首歌的处理中——这通常需要规模不小的改动。 其它任何形式的努力和这种付出都没有可比性，因为我们都能确切听到（甚至是能看到）这自由的音符从每一个人的指尖倾泻流淌，共同构成一首歌，好像乐曲和乐器都拥有了它自己的灵魂：无数个排练（甚至是演出时）我们都会完全沉浸在自己构筑出的这音符的世界中，观众们会说「那鼓手摇头晃脑地边唱边敲好开心呀，像个孩子」。 今年听了几场 live，上了几次 livehouse（如今演出需求过于旺盛，一支乐队要上 livehouse 并不困难）：每次学长都会戏谑地说「大家可都是上过 livehouse 的老前辈了」——好像还是在那个需要争取演出机会的时代。 「乐队真是那种，即便是在整个人生的尺度上，也会熠熠生辉，几乎是仅有的没有任何遗憾的美好回忆」，一年一度的音乐节结束后，我发了这样一条推特。乐队这段体验真是弥足珍贵（本文的头图很好地反映了这一点），几乎没有什么遗憾，唯一可惜的就是，快要毕业的我们已经很难再继续延续这迄今只持续了短短一年的美好，下一次演出，或许就是告别演出了吧。 记忆，阅读，另一种目光3今年的阅读并没有很多（每年都是如此 = =），不过我对黑塞的喜爱程度算是正式超过了加缪（没办法，谁让加缪的作品那么少），也非常幸运地读到了两位东欧作家的作品：辛波斯卡和切斯瓦夫 · 米沃什。权且贴一段自己今年写下的文字来概观我对这些作家的感受： 晚上顶着困意看了几页切斯瓦夫米沃什的《路边狗》，意外地发现很好看（也很好读），这种词句简单、文笔凝炼、富有哲理，总是絮絮叨叨的随笔和碎语总让我想到零星的几位朋友写的东西。顺便让我想到辛波斯卡的《碎语，奇迹市场与希望》。 其实如果这种「絮絮叨叨」的气质（实质是一种连贯思维的能力，有条理地专注地思考并整理，而非发散性地跳跃、遗漏诸多细节，亦非不时陷于要不是情感要不就是过往中）是诗人或者文艺家（如果按传统的理解将诗人理解为文艺家中最文艺的那类的话，那么这一点在诗人身上想必也会表现地最为明显）的必要思维方式的话，那么我显然是不适合这几行的了，甚至进一步说，我恰恰站在这种气质的反面。 当然，要说这是更为广泛的思维方式、而非仅仅局限于文艺界也是有道理的，当然我个人并不这么期望，毕竟自己的反面所占据的领域还是越小越好…. 当然其实也不一定罢…… 时至今日我都非常清楚地记得第一次读普希金的某首诗其中一句非常精妙的比喻时的那种震撼，还有读加缪《第一人》的第一章「云到不了东面的海了，现在势欲淹没整个地区，…」那段，加缪在短短一段里将天与地、南与北、历史与当下等等独立复杂的元素游刃有余地织成一段精妙文字时的（请允许我开个小小的玩笑（（（ ），卡夫卡口中的 ** 般的快感，还有读扎加耶夫斯基的一些现代诗，其中一些仅仅四行就能涉及五个地方六种意象时的惊奇，或许极具跳跃性和创造性的思维其实也是尤其是浪漫主义文学和一些修辞学中非常重要的部分… 当然就论我个人的话我觉得我的口味逐渐在从以前的 偏向浪漫主义、歌颂和宏大 向 内敛、含蓄、冷峻 转变，我觉得想比加缪我现在可能更加喜欢黑塞，尤其是吴忆帆（不是吴亦凡（（（（ ）翻译出的那种冷峻的抒情诗人气质….（来自我的 Telegram Channel） 黑塞、辛波斯卡、米沃什、雷蒙德 · 卡佛的小说和诗歌，还有一些杂七杂八的大陆科幻，再加上关注的诗歌和思与诗两个很不错的微信公众号不时推送的一些诗歌和有关诗人的评论，差不多就是我今年阅读的全部了。今年认真读了很多诗，也背下来而不少；在这里再贴一首目前为止最喜欢的诗歌：辛波斯卡的《在一颗小行星下》，作为 “压舱石”（最后一首）收录在湖南文艺出版社的《我曾这样寂寞生活》中，译者胡桑。顺便一提这出版社，就那么几首诗，反复出各种各样过度装帧的集子来靠辛波斯卡圈钱，有点恶心… 在一颗小星星下[波兰] 辛波斯卡 我为把偶然称为必然而向它道歉。 万一我错了，我就向必然道歉。 请别生气，幸福，如果我将你占为己有。 死者，但愿你容忍这一切，我的记忆正在枯萎。 每一秒钟我都忽视了整个世界，于是，我向时间道歉。 我为将新欢当成初恋而向旧爱道歉。 原谅我，远方的战争，原谅我将鲜花带回了家。 原谅我，外露的伤口，原谅我刺破了自己的手指。 我为小步舞曲唱片而向在深渊里呼喊的人道歉。 今天，清晨五点我仍在熟睡，为此我向等候在火车站的人道歉。 宽恕我，被追逐的希望，宽恕我一再地大笑。 宽恕我，沙漠，宽恕我未能及时带来一匙清水。 还有你，猎鹰，这些年你依然如故，在同一个笼子， 在空中，你的目光凝固在一处， 原谅我，即使你变成标本。 我为桌子的四条腿而向被砍倒的树木道歉。 我为小回答而向大问题道歉。 真理，请不要太在意我。 尊严，请对我大度些。 容忍我，哦，神秘的存在，容忍我拆掉了你裙摆上偶然的针线。 灵魂，请别指责我偶尔才拥有你。 我向所有事物道歉，我不能随时到达每一个地方。 我向所有人道歉，我无法成为每一个男人和女人。 我知道，只要我活着，就不能变得公正， 因为，我是我自己的障碍。 言语，不要怪罪我借用了庄严的词句， 又竭尽全力让它们变得轻盈。 （胡桑 译） 尾声：这被鞭策的日子4对于在上文已经记叙了的许多段体验，其时我都有一种感觉：脑海中多次响起一个声音，它告诉我要好好铭记当时的一切，因为这可能是以我一生的尺度来看也为数不多、甚至是唯一的经历——我努力地铭记它们；而这种茫然若失的情绪在本文的开头已经描述过。现在对那些已然过去但仍然闪烁的珍贵回忆，唯一可惜的就是它们不够经久，也很难有机会再体验了。 但我并不后悔，我并不拒绝踏入这条河流5：那个台下观众随着 Free Loop 中一句句温柔的歌词来回热情地挥动手机的时刻；那个在 livehouse 后台侯场时躺在沙发上、仅一墙之隔的舞台传来震耳欲聋的声响震得我的耳膜有些难受的时刻；那个凌晨四点看到雪花（一开始是冰粒）从透着粉红色和冰蓝色微光（是的，严重的空气污染）的苍穹边缘缓缓落下的我激动地大喊「这是广东孩子的人生第一场雪呀」的时刻；还有那个在广州某座可以看到万胜围有轨电车终点站和东圃特大桥的一座高层居民楼的某个角落，凌晨两点突然抬起头，透过窗外看到就像《南方》6 一样的大雨磅礴 “势欲淹没整个地区”7，远处灯线逐渐融化在无穷无尽的雨丝中，费力地穿过弥漫整个空间的深沉雾霭的时刻；这些时刻和其它的许多事情，随着这快若飞矢的一年一并结束，永远停留在那个希望自己是、更希望自己永远是丰富的、浪漫的（在「浪漫主义文学」意义下）、热情的 18 岁孩子的心灵深处，现在这短暂的一年也被一种落日余晖般的金色光芒所笼罩，在这被鞭策的日子的终点，有关它的一切、无论是欢欣还是苦痛，都变得如此可爱和迷人，有如从梦中摘下的回忆8。 &lt;全文完。&gt; 脚注 1：语出阿瑟 · 克拉克。 2：「在我们的生命中有若干个凝固的时间点 / 卓越超群、瑰伟壮丽 / 让我们在困顿之时为之一振 / 并且弥漫于我们全身，让我们不断爬升 / 当我们身居高位时，激发我们爬的更高 / 当我们摔倒时，又鼓舞我们重新站起」引自阿兰 · 德波顿《旅行的艺术》（我个人不是很推荐这部作品）中有关威廉 · 华兹华斯的段落，原文和译者均不详。 3：这是大陆东欧文学出版计划《蓝色东欧》的总序，作者是高兴：之所以引用它作为这一节的小标题是因为今年除了黑塞（非常幸运地）新近喜欢上的两位作家都来自东欧国家波兰。 4：这段时光里我总感到一种黑塞《克林索尔的最后夏天》式的浪漫（「被鞭策的日子」），好像这是我青春之火最后的恣意燃烧。 5：出自我喜欢的乐队蛙池的河流，他们还有一篇同名专访。 6：达达乐队的《南方》。这是我们社团的社歌，每次演出完乐手和留下来的观众都要一起合唱。「彭坦说写这首歌是因为有天晚上，北京突然下起大雨，雨声特别大，那天他没关窗户，窗外潮湿的感觉扑面而来，那感觉就像在武汉。」 7：引号内的表达是我从阿尔贝 · 加缪《第一人》的开头学到的。我很喜欢这部作品——不过要是能写完就最好了… 8：最后这句话出自奥尔罕 · 帕慕克《伊斯坦布尔》。顺便写完之后读来这整段感觉都很像黑塞《艺术家的命运》的结尾…","link":"/life/the-end-of-2021/"},{"title":"简单聊聊编程语言的哲学，以及关于 Rust 的一些想法 (1)","text":"本文是一篇「小作品」。 草，写着写着发现越写越长，一点也不「小」嘛。 或许我真的应该尝试一下「小」作品的体例才是。 我的长期TODO列表里已经躺着五六篇以“博文”开头的条目——原本想着寒假一周一篇很快就能写完，然而到现在也没动笔。爆肝填坑了一个星期，今天实在有点累，不大想打开 RustLion，于是把这篇坑了很久的文章写一写。 在这几篇坑了这么久的文章中其实有一篇已经写了前半部分了，然而咕了太久后半部分要写什么都有点不大记得，于是只能前功尽弃… 本文的主要内容是从我个人的经验出发，简单聊聊对于 Rust 的一些想法和体会。我会尽量避开诸如 “文档质量良好”、“很有特点” 这类宽泛的概括，而尽量将自己在使用 Rust 编程的过程中感受到的一些特别之处、尤其是和此前经历的不同之处拿来说说。我期望如此行文能使得本文对无论是 Rust 初学者、还是仍在观望的开发者甚至是 Rust 老手们都能带来一定启发。 &nbsp; 可能过时 2022/11/17：经过快两年的学习和工业实践，我对编程语言又有了新的认识。本文中对于 Ruby 的评论、尤其是对于 Ruby 优于 Python 的评论，已不再是我当前的看法。不过，很大程度上我仍然保持着占本文主要篇幅的对 Rust 的各种见解，但由于在过去的一年间我的兴趣发生了重大转移（转向系统、尤其是数据系统的领域），我现在较少使用 Rust 语言（这恰恰是由于在本文中提出的一系列 Rust 语言设计不尽人意的原因），较少关注 Rust 语言社区，也更少广泛地思考编程语言本身，本文中的许多观点可能不再能反映编程语言发展的最新情况。 如上文所述，占本文主要篇幅的观点并未明显改变，如果将来发生这种情况，我会修订或补正本文。 本文将主要按这些体会主要关注的语言侧面组织，每一点之间的内容基本独立，我将尽量涉及从语言哲学到线程安全的实现细节等多个方面和层次的内容。 由于篇幅原因，本文将分截为两到三篇文章发出。以下是文章内容的粗略概要（很可能有变动）： 编程语言的哲学 Rust: “be explicit” 复杂性 “子语言” 并发和线程安全 第一部分：主要引述来源 继承 V.S. 组合：另一种思维方式 Typeclass 和 mod 元编程和宏系统 结语：“language adopted to fill a niche” 第二部分：主要引述来源 本文将包含以上概要的第一到三部分。其实原本真的真的不想写这么多…… &nbsp; Cover image by&nbsp; かざり &nbsp;on&nbsp; Twitter. 编程语言的哲学一直以来我都认为，一门计算机语言的哲学对语言多个方面的特性都有着非常重要的影响，理解语言的设计哲学对理解语言为何如此有着重要的意义。比如，个人认为： Java / JVM：打造大规模企业级程序的首选平台 这一定程度上解释了 Java 选择较重的运行时（因而免除了手动内存管理的麻烦），并且为了在具有较重运行时的前提下同时达到企业级程序要求的 “处理大量数据时的性能开销仍然可以忍受”，Oracle 在 JVM JIT 以及GC的设计和实现上投入很大。Zing VM 拥有目前市面上性能最强的GC器之一（据此处，Zing VM 的 C4 可以在管理高达2TB堆内存、外加10TB堆外内存时仍然保持 5ms 以内的并发GC停顿），而新近出现的几个Hotspot GC 器（Shenandoah、ZGC）的工作表现同样相当不错（Grammerly 报告工作在生产环境的 Shenandoah 在 10k req/s 的 QPS 和 60GB 的堆内存下仍然具有 &lt;10ms 的GC停顿（hicuup），见此处）。另一方面，据 Mark Reinhold 所述，Hotspot JVM “目前70%-80%的工作都是在C2（第二级JIT）上”，大量研究表明经过深度JIT优化的字节码可以达到和原生代码同等、甚至更高的效率（GraalJS 是使用 Java 实现的 JavaScript 运行时，它工作在为高效执行跨多个语言的应用而特别设计的虚拟机 GraalVM 上，近期有报告指出深度优化后的 GraalJS 可达到优于 V8 的执行效率（参见此处），这个结果还是蛮搞笑的……）。 重要的一点观察是，通过较重的运行时，开发人员可以将注意力更好地集中在业务本身，而非各种内存管理策略带来的、通常是令人气馁的复杂性和安全问题。据此引文，尽管业界已在大量静态分析和动态检查工具（如 Cppcheck、Valgrind Memcheck 等）上花费了数亿美元，并付出了同样艰苦的努力制定编程规范并培训程序员们，每年仍然有超过70%的软件漏洞（CVE）与内存安全问题有关。从这个角度上来说，托管语言（managed language）天生地比非托管语言（unmanaged language）更好地适合大多数的应用场景——在这些场景下，开发人员生产代码仅仅是为了解决常规的业务问题，有关代码优化、大内存管理等等细节，交由较重的运行时、进而转嫁给专门处理这些复杂方面的虚拟机专家们就好了吧。 在这个问题上，Rust 选择了一条独特的道路：它通过严格的编译规则和精心设计的标准库达成了通过编译器强制保证的内存安全性——如此既没有内存不安全的风险，又没有运行时的性能开销。然而，这样的设计加重了程序员的心智负担，并带来了主要的复杂度——对于编译器和编程人员皆是如此——和“比较陌生的方面”，而这样的复杂度和我们通常所说的 “复杂” （Scala 式的 “复杂”）之间存在一定区别，这点会在下文中展开来讲。 Scala：用最少的特性，做最强的语言 Scala 是一门编译到 JVM 字节码的多范式语言。在所有工业级编程语言中，Scala 以其惊人的复杂度和优雅程度而著称。个人认为，Scala 在考虑语言设计时的重要方面是更加重视特性之间的 “联动”：如果能通过几个更加基本的特性来实现一个需要的特性，Scala 会优先选择更好地支持这几个小特性，而不是为了某一个常见的编程 idiom “开近道” ——这样的语言设计有时能够获得非常好的“联动”效果，因为几个小特性各种各样的组合方式通常比几条近道能表达更多的东西，当然也要复杂得多。一个非常好的例子是 Scala 中的枚举：大多数语言中的枚举（如 Java、Kotlin、C# 等）都是作为一个特殊的语法（enum class）来实现，它由编译器负责展开；然而 Scala 通过两个更加基本的特性（类型别名和继承）实现了枚举这一特性，并未在语法层面提供任何特殊支持。相似的例子还有类型标识符由类型投影这一个小特性实现，而类型投影又和结构化类型发生“联动”最终产生了类型 lambda 这一堪称神奇的特性。 简单展示一下这个神奇的存在，通过 typeclass 范式为 Map 类型实现 map 函数： 123456implicit class MapFunctor[K, V1](mapV1: Map[K, V1]) extends Functor[V1, ({type λ[α] = Map[K, α]})#λ] { def map[V2](f: V1 =&gt; V2): Map[K, V2] = mapV1 map { case (k, v) =&gt; (k, f(v)) } } 看到那串 λ、α 了吗？这，就是 Scala。 不过这串代码依然给我一种非常优雅的感觉。目前能让我感觉十分优雅的还是只有Scala（和 Ruby？）…… 一直没有机会拿来写点复杂项目啥的，其实感觉都要忘光了…… 哭哭 算了，等 Scala 3 用起来了再完全重学吧（（（（ Ruby：极致的脚本语言 Ruby 的许多特性强烈地偏向对脚本语言的良好支持。在我看来几乎从任何一个可以想象的方面来说 Ruby 都要比 Python 更加合适作为脚本语言的默认选择。比如 Ruby 支持任意地方法覆写，你甚至可以覆写在 Int 中定义的 + 方法从而立刻把REPL给崩掉… 比如 Ruby 非常好地普及了守护（guard）的使用，从而使得大量的 idiom 有了 one-liner；比如这是一门动态类型语言，编译器只会阻止很少的事情；比如 Ruby 简洁的闭包语法（事实上 Rust 中的闭包语法正是沿袭自 Ruby）、do 语句以及对各种常用集合操作的良好支持，使得以闭包作为参数的标准库API基本可以替代循环；比如各种高度动态的语言特性和内省（introspect）机制。良好和高度动态的设计使得 Ruby 不仅适合编写各种 dirty but works 脚本，同样也适合工业的快速成型。 Rust: “be explicit”Rust 一点重要的设计考虑，在于 be explicit。或许是看到了 C++ 长期坚持在各种问题上走隐式优先的策略如今吃了太多苦头（比如隐式类型转换一向以来被视作是 “bug 的一大来源”，甚至还有 std::string str = 12; 这种毒瘤写法…… 而且似乎删除函数也没帮上什么忙（😒 ）于是 Rust 选择了要求程序员明确指明绝大部分转换的写法——即 “be explicit”。作为一门侧重在受限资源环境下尽量保持极低性能消耗的语言，Rust 要求对资源的创建必须显式声明。这一点首先以 Rust 中全局采用移动语义（move semantics）和严格的引用/借用检查器为基础，再通过标准库中的的一些 trait（Typeclass 式的）强制资源创建的显式声明。最为代表性的例子自然是 to_owned： 12let str: &amp;str = &quot;Hello&quot;;let str: String = str.to_owned(); str 类型作为编码在二进制文件中的字符串，其类型显然应为这一串二进制字符串的一个 slice（即 &amp;str）。它不在堆上占据空间，而仅仅是一个指向文件中某一段的指针；自然而然，对一个指针执行字符串拼接是不可能的——于是在 Rust 中，连续地拼接字符串不仅语法繁琐，而且还需要对语言有一定的熟悉： 123456let s1 = &quot;hello&quot;;let s2 = &quot; &quot;.to_owned();let s3 = &quot;world&quot;; let concat = s1.to_owned() + &amp;s2 + s3;println!(&quot;{} {} {} -&gt; {}&quot;, s1, &amp;s2, s3, concat); Rust 要求在各种引用、分配内存时显式声明，这使得程序员更加关心引用的传递以及资源的消耗：以程序员的更高心智负担为代价，Rust 不断提醒着程序员注意资源分配，通过语法的冗长督促提醒程序员尽量减低资源使用。 Rust 同样具有一些程度的隐式（implicit ，注意不是 Scala 语境下的那个 implicit）：如通过 Copy trait 实现隐式的复制语义、解引用强制多态（deref coercions）等。Rust 谨慎控制了这些隐式的适用范围，前者仅适用于少数复制成本极低的内建类型（而如 String 一类有较高潜在复制成本的类型则需要通过 Clone trait 显式指定和调用；Clone 和 Copy 的分立是 Rust 在 be explicit 哲学 和 语言易用性 之间取得的良好折衷），后者则仅适用于函数和方法传参。 有时候，复杂的分配声明、引用和解引用转换会导致冗长难读的代码。Rust 通过一些标准库 trait 部分缓解了这一负担，并通过宏（macro）系统（下文会更深入地涉及）为一些常见范式提供了全兼容的写法，将这一负担转嫁到宏的实现中。比如，众所周知，大家都不喜欢用 + 做字符串拼接，in Rust, we use format! ： 123456let s1 = &quot;hello&quot;;let s2 = &quot; &quot;.to_owned();let s3 = &quot;world&quot;; let concat = format!(&quot;{}{}{}&quot;, s1, s2, s3);println!(&quot;{} {} {} -&gt; {}&quot;, s1, &amp;s2, s3, concat); 这一点哲学，是 Rust 的首创吗？我想不是。写到这里，我在想，是不是所有与ML系（或者说 Haskell 系？）语言的元素（如 Typeclass、ADT through datatype + pattern matching with exhaustiveness checking 等）有强烈关联的语言都更加倾向于 be explicit。Rust 如此；Haskell 如此；C++ 20 的一个失败的 concept 的设计草案（被称为 Indiana Concept）同样如此（我觉得这个草案被否决某种上是因为在一门本来鼓励隐式的语言中去推行 be explicit 只会导致如 late_check 这样明显权宜之计的简陋方案，即是说 Typeclass 式的哲学与 C++ 本身的哲学并不契合是导致 Indiana Concept 未能取得成功的重要原因）；SML 做得还要更绝，它甚至不允许对实数进行判等，因为这样的判等本身隐含了一种对精度的约省。 这样一簇语言设计思路为什么都走向了 be explicit 这一哲学？这一哲学是必然隐含在人们通常界定的 “ML味”（即：带类型推导和参数化多态（但没有子类型多态）的静态类型系统，即 Hindley-Milner 类型系统；datatype 支持的 ADT 以及模式匹配（pattern matching）和解构句法；一个模块子语言，它提供了巧妙的隐藏机制且某种程度上正是一种 Typeclass 范式的实现（关于这点可能会另写一篇文章简单说说），即人们常说的 ML module system）中的吗？还是说，这仅仅是同一帮人带着同样的思想和哲学反复参与到各种语言及语言草案的设计中？ 比如说，Dan Grossman 就说：comparing real numbers with == is a really bad idea. 然而我其实觉得还好…… 其实如果正确规定浮点数的判等（比如说， $a-b = \\delta &lt; \\epsilon =10^{-5}$ ）并在文档中广而告之这一默认行为，或者强制要求程序员在执行浮点数判等时必须指定 $\\epsilon$ （指定采用 “默认值” 也算指定），可能会是一个解决方案… 然而有没有人买账呢。:-( 其实老实说，在我个人的编码工作中是极少遇见浮点数的。或许根据众所周知的编程语言设计原则让那些罕见的操作（比如浮点数判等）繁琐但精确会不会是一个不错的选择？🤔 复杂性我想大家应该都会同意，Rust 是一门复杂的语言。但是 Ruaaast 的复杂性并不在于这一门语言表达力多么惊人、程序员能够接触到多少新的特性、进而将此前多少无法简洁表达的抽象统统实现，而是在于 Rust （出于各种权衡）引入的独特所有权和线程安全机制将大大挑战程序员以往的思维——或者说，Rust 带来的主要的复杂度和陌生之处，并不用于向程序员的工具箱中增添多少强力的工具（事实上，个人认为，很大程度上 Rust 的表达力并未显著超出ML系语言的一般水平，详见下文），而是用于解决很多其它语言中并不存在的问题。 Rust 具有复杂的类型系统。在 Rust 中，不仅值和引用（以及和引用的引用，引用的引用的引用，…）不是同一个类型，不符合生命周期约束的引用，同样不是同一个类型，不匹配的传参将会被编译器拒绝（生命周期 “匹配” 的规则，能不能看作是生命周期的 subtyping…？比如，&amp;'static 总能符合各种生命周期约束）。 “子语言”借用知名PLT大V千里冰封在某次技术分享中的话语，那就是和绝大部分计算机语言一样，Rust 同样也是由很多门子语言组成的。简单列举一下，我们可以得到： 表达式子语言规定了表达式（expr）的句法、类型检查规则和执行规则（这三点其实是 Dan Grossman 在课程 Programming Languages 中提出的：syntax, type-checking rules, evaluation）。 模块（mod）子语言指明相对独立的命名空间相互暴露和引用的方式。众所周知，这在 Rust 中是通过 mod 的引用（use）来实现的。 多态子语言（注意，此处的「多态」指 polymorphism，即 “参数化多态”、“子类型多态” 意义上的多态，而非 Java 语境下的那一种多态（对于 Java 语境下常被提及的多态，我想更多地应该是指动态分发 dynamic dispatch）…）为语言提供了一种表达力，它使得同一段代码能够应用于各种不同的类型。向这些类型施加限制（并转化为相对于这段代码而言的 “已知条件”）的方式、语法和规则，由这门子语言指定。C++ 中采用的模板（相较于 多态 polymorphism 这个术语，Bjarne 本人似乎喜欢把这个叫做 “泛型编程 generic programming”，但为了避免和 Java 式的那种泛型混淆我们还是称多态好了（然而 “多态” 也容易和那种 Java 式的那种多态（实际上是 动态分发 dynamic dispatch）搞混嘛（（（（😒 所以最终结论是 Java 的广泛流行对各种术语的界定真是后患无穷（（（（ （光速逃🤯 ）、Rust 和 Java 存有一定近似（别打我）的泛型系统（尤其是在约束这一层次上）、ML系语言中的参数化多态（'a），皆属此项。 Rust 的多态子语言基本通过基于 trait 的可加和 context bound 施加限制（e.g. T: Clone + Debug），这在 Java 中可以通过基于 interface 的 bounded type paremeter 近似达成（e.g. T extends A &amp; B）。个人认为在这一层次上 Java、Scala、Kotlin、C# 一类的语言由于具有子类型化（subtyping）要更加复杂，它们需要处理诸如逆变和协变（还有存在类型 existential type）一类复杂的问题（并导致大量微妙的设计差异，比如 Java 的定义处类型变异和 Kotlin 的声明处类型变异，显然后者是更优解）甚至有时候还有数组协变这样的难搞历史包袱。 其实这段有点扯淡…… 因为 Rust、Haskell、Scala 式的 Typeclass 原语允许一个新增的类型实现（分别通过 impl 块、隐式转换 implicit conversion、instance 块）某一个预先定义的 typeclass（虽然这些语言中一般都会 孤儿规则 orphan rule 限制这样的 “实现” 的适用范围），而以 Java 为代表的一类语言中的 interface 其实是不具有这种能力的。 这其实是对著名的 表达式问题 Expression Problem 的解的探讨…… 某种程度上个人认为 typeclass 其实是对这个问题一个很好的解，关于这个问题以及不同语言（Haskell、Scala、Rust；C#、Kotlin；Ruby）的不同解法（Typeclass；扩展函数；mixin）有空在以后的博文中再聊. 😋 另一方面，Rust 有一些它需要关心的特殊问题。由于 Rust 中对象创建时的内存分配由编译器完成，Rust 引入了 marker trait Sized，它指明被标记的类型的大小在编译期可确定（这是程序能够通过编译的重要条件），并默认所有的类型（除非特殊声明）均是 Sized 的。 Rust 实现这一点的方式是，向语言中引入了新的语法 unsafe auto trait。当一个 marker trait 被声明为 auto 时，编译器会自动为所有类型实现该 marker trait ——除了预先指定的那些反例，如 impl !Trait for Type。综合来看，这一套语法要求编译器为反例之外的所有类型自动生成对某一 marker trait 的实现。 为了使一些 context bound 能够适用于非 Sized 的类型，Rust 又引入了语法 ?Sized。当它出现在一个 context bound 中（如 T: ?Sized）时，表明限制该类型（T）为 Sized 或非 Sized 的。（某种程度上 ?Sized （而非 T）才表示 Rust 中的 “所有类型” ？） 下文将要提到的 Send 和 Sync 也是通过这样的方法实现的。 个人认为，问题在于（花了超多时间和笔墨讲前面的这几点可却仅仅是个铺垫…… 超级累啊 😣😣 ），这一部分语言设计并不算好。表观的定性认识是，Rust 专为一些基本可以说是 实现细节 的东西专门提出了几条语法，并且将这几条语法的适用范围牢牢限制在它们之所以被发明出来的那一部分——即是说，这一部分语言设计，几乎不可能与语言的其它部分产生联动，而良好的特性联动无疑是语言设计上佳的重要标志。另一方面，出于类型系统可靠性（soundness）等各种各样的考虑，这些 auto trait 在语言各个层面上的工作方式（比如，supertrait，模式匹配等）均和一般 trait 存在差异——这与良好语言设计的另一个标志，即 “创造尽量少的特例” 相悖。个人的认识是，这些 auto trait 是贯穿 Rust 语言的几个深“洞”，它们要求语言各处为它们制定独一无二的规则，并且将这些规则牢牢限制在它们本身。 除此以外，由于 ?Sized 肩负着 “所有类型” （存疑？） 的职责，这一极其局限的语法在大量代码中均有出现（比如标准库、tokio、一些第三方集合库，等等）。将一个常见且重要的职责赋予一条怪异、适用性低、并不直观的语法，长久以来提高了初学者的理解负担（“依赖里头突然看到了个这个，它到底是什么意思啊？”），并使人们不断提出这样的问题：为什么这三条语法不能广而推之？于是我们看到有关 negative bounds 的语言设计提案（RFC）和讨论被不断提出，语言设计者们不厌其烦地解释为什么这是个坏主意，以及为何更加细致考虑的特性（如 specilization）才是正途。 其实无论如何，Sized 都是一个只有 Rust 才会面临的特殊的难题——正如上文所述，这部分复杂度是为了解决一个其它语言中并不存在的问题。这部分设计，将原本就是泛型的意义强行嵌入到某一个 trait 中（“T 不就是所有类型吗？为什么还要造一个 T: ?Sized 呢？”），无论如何，这个问题难以优雅地解决。 生命周期子语言是 Rust 中极为特殊的一部分：同样，它也是为了解决其它语言中并不存在的问题。Rust 要求在 结构体 struct——注意，Rust 的结构体 完全不是 C / C++ 中的结构体——中出现的引用必须具有生命周期标记，语法借用了泛型中类型参数的语法： 12345struct BorrowedPoint&lt;'a&gt; { name: &amp;'a str, x: &amp;'a i32, y: &amp;'a i32,} 123fn print_multi&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) { println!(&quot;`print_multi`: x is {}, y is {}&quot;, x, y);} 尽管 Rust 已经实现了各种各样的生命周期推导规则和尽量复杂的生命周期分析（称作 non-lexical lifetimes），很多时候仍然需要程序员手动标明生命周期标记。对于结构体的生命周期标记尤其让人头疼：带引用的结构体 的生命周期标记是强制要求的，不能省略；而一个结构体上的标记会扩散到整个代码库中，即便对于能够自动推断得出的生命周期，也要使用生命周期标记省略语法 BorrowedPoint&lt;'_&gt; 注明。这使得相关的重构要更加复杂。 我仍旧相当惧怕在结构体中使用引用。很多时候，我并不能确切得出一个结构体到底是否适合包含引用的结论（这方面是否有一些指导原则和官方文档？），而贸然执行重构得来的是大规模的编译错误、繁琐的修正，有时最终又发现并不适合使用引用——典型的情况是在跨越线程边界时。 在很多情况下（个人经验是以 带引用的结构体 为主）仍然需要手工标注生命周期，而这一点仍然、并持续带来显著的心智负担。 自然要问的问题是，仅靠对程序的 静态分析 static analysis，我们能够将程序中每一个引用的生命周期分析到什么地步？即是说，Rust 的生命周期推导本身、以及类型系统和生命周期系统的配合，是否还有更加完善以更进一步降低程序员心智负担的可能？ 我仍然相当盼望不再强制带引用的结构体必须带生命周期标记的那一天。 除此以外，生命周期的继承机制（如：'a : 'b）和一些特殊生命周期（&amp;'static 和 T: &amp;'static ——注意，尽管两者语法极其相似，但语义却有重要差异，这是初学者容易犯的一个常见错误）的存在使这一部分的语言更加复杂和难以理解。 以上所有，在 Rust 的多种生命周期传递方式（函数/方法参数、结构体、闭包捕获等）各异的局限下，创造出多处特例，使得它的工作方式更加难以归纳和掌握。 可以看得出来，某种程度上本段对冰冰的 “子语言” 观点（不要打我）仅仅是作名词意义上的借用——和基于 PLT 研究风格的分析不同，本段的这种拆分与其说是在语言研究上有着什么启发性意义，不如说仅仅是将一门语言分块来说会更加方便而已。关于他的这部分观点的更多内容，详见文末 “主要引述来源”。 并发和线程安全我真的好累，眼睛还疼学校里还没有人喜欢我，所以这个部分只能简单写写算了。 在一门没有运行时的语言里实现易用的并发是有挑战性的——特别是线程安全的并发。Rust 通过向标准库中引入几个设计精巧的 API —— Sync、Send、Pin 等——较好地解决了这个问题。Rust 一个重要的并发库 tokio 生态完整（包括基本协程支持、同步原语（信号量 semaphore、通道 channel）、流式并发、网络和网络包解析、结构化日志等等）、文档质量优异（事实上 tokio 的教程是我所了解过的开源项目中质量最高的之一 🤩），一定程度上简化了在 Rust 中实现线程安全并发的困难。 从一般工程实践上看，在 Rust 中编写良好的线程安全并发，需要了解的包括： 一些基本的同步原语：信号量 semaphore、通道 channel、互斥锁 Mutex、读写锁 RwLock 等 一些 Rust 特有的、为保证线程安全而特别设计的 auto marker trait： Sync 和 Send 一些 Rust 标准库 trait 和相关机制存在的必要性及用途：Pin / Unpin、Box::pin、tokio::pin 特殊生命周期 &amp;'static 以及 T: &amp;'static 的含义（尤其是这两者如何不同） 以及一些智能指针（其存在的必要性和局限，横向的比较，性能开销等等）：Box、Rc、Arc、RefCell 小问题： 123type MessageStream = StreamMap&lt;String, Pin&lt;Box&lt;dyn Stream&lt;Item=Arc&lt;PUBLISH&gt;&gt; + Send&gt;&gt;&gt;;type Publishers = Box&lt;dyn PublisherRepository + Sync + Send&gt;;type SyncSessionManager = RwLock&lt;SessionManager&gt;; 试解释以上类型别名中各个 API 出现之用途？ 除此以外，如果需要深入理解 Rust 并发的实现原理，还需要了解 Future / Waker、Scheduler 等。个人体会是并发库中各种并发操作的实现，由于 Future / Waker 范式本身固有的复杂性和理解难度以及惯用实现风格的原因，相关代码并不好读；这点在研究 poll 簇并发操作等方面时会带来一些困难。 在任何编程语言中实现线程安全的并发都需要细致的设计考虑和复杂的工程实现。Rust 社区呈现出如此完全的生态和易用程度，足以为开发人员和软件生产带来良好的体验，并为其它编程语言的设计带来重要启发。 第一部分：主要引述来源以下简单列出本部分文章主要引述资料的来源。有一部分引文已在原文中以超链接形式给出，故在此处略去。 《Scala 程序设计语言 (第二版)》；Dean Wampler, Alex Payne 著 王渊，陈明 译；人民邮电出版社，2016 Stroustrup, B. (2020). Thriving in a crowded and changing world: C++ 2006–2020. Proceedings of the ACM on Programming Languages, 4(HOPL), 1-168. rust-lang/rfcs#1210 - specialization https://github.com/rust-lang/rfcs/blob/master/text/1210-impl-specialization.md 《当我们在谈论编程语言的时候我们在谈论什么》，千里冰冰 https://ice1000.org/plct/0 https://github.com/Ray-Eldath/Telesteller/blob/master/src/server.rs MacQueen, D., Harper, R., &amp; Reppy, J. (2020). The history of Standard ML. Proceedings of the ACM on Programming Languages, 4(HOPL), 1-100. 本文就这么多。感觉其实没讲什么很有意思的东西… 希望还有机会写完本文。祝大家新年 Ruaaaaaaaaast 愉快！ &lt;全文完&gt;","link":"/programming/thoughts-on-rust-1/"},{"title":"还有什么应该去写的事情？","text":"大概两个星期以前，被朋友问到了一个问题。她问我：如果明天就是世界末日，你有没有什么想做的事？ 她自己的回复是要立刻到重庆（原话大意是 “不管发生什么我都要立刻飞过去”）去吃正宗的重庆火锅，因为在这边吃到的所有火锅都不怎么样。她说，这种回复其实表明她并不对自己当下的生活感到全然满意，因为明天就是世界的终结也会想去「最后疯狂一把」，而如果是真正满意自己的生活的话，回复应该是 “该怎么过就怎么过” 才是。 这几天我也一直在想这个问题。如果明天就是世界末日，我又会去做什么呢？ 想过了这几天，也没有想到答案。开始在 PingCAP 实习以来，换了键盘换了手机换了电脑换了耳机，有了微不足道的存款有了不值一提的给父母减轻压力的自由，我在想，我还想要些什么？ 有没有什么事情是想去做的？有没有什么东西是还没有写够的？技术？这重要吗？做这些仅仅是为了简历上的一行字？卷来卷去，没有目的？（如果你看出了我在引用哪里，欢迎在评论区留言）旅游？去见谁呢？上海的风景和深圳的风景有不同吗？成都的风景和广州的风景有差别吗？ 这时候就会觉得，如果没有什么想做的事情，如果也没有想见的人，七八十年的人生是不是太长些了？我奇怪，人们是靠什么度过如此如此长久的时光的？（长达六七十年？）翻开《世界的苦难》，世界和它的苦难依旧一如既往？三四十年都在晦暗的街头烧杀抢夺吗？五六十年都在北方的城镇执行判决吗？这些人不会觉得无聊、哪一天像是体验够了所有的事情？如果没有工作，不受制于生存的必然，还有什么是还想去做的？ 这时候我就会想起汉娜 · 阿伦特在《人的境况》里说的话，她说，人类是在万物都在永恒地做圆周运动的世界中，唯一划着直线的存在。因为人是有死的，人是有「生」的，今天的 Ray 在写《还有什么应该去写的事情？》，今天的 Ray 的室友在填学校的留校申请表，这是两个不同的人。我们不会觉得两只猴子有什么区别，所以猴子是永恒的，靠着自然繁殖长久地存在下去。 既然自然剥夺了人的「永恒」，人需要另外一些方法获得永恒。人向自身赋予意义的方式就是创造了空前复杂的人造物的世界。「工作」，给打工人赋予自身意义的途径，使打工人能够在有些过于悠长的人生中打发掉时间（原话说的实在是很漂亮，可惜我记不得了），并且提供了「人造物的世界」，在这个世界中，人类中的最优秀者能够留下痕迹，这些痕迹将超越他们个体生命的长度。这种 “劣等” 的「永恒」，我们称之「不朽」。 这种 “劣等的永恒”，它的劣等性在于，剩下的人应该怎么办？那些人类中并非最优秀的人，除了工作的必然，除了可悲的生存的必然，还会想做些什么呢？这些想法是如何支撑住他们少说也有半个世纪的岁月的？ 这时候我就会想起很早以前看到的一段无人不晓的话，辛波斯卡在她的诺奖演说词中驳斥了它。这段话来自圣经《传道书》。“已有的事，后必再有。已行的事，后必再行。日光之下并无新事。 / 岂有一件事人能指着说，‘这是新的’。哪知，在我们以前的世代，早已有了。 / 已过的世代，无人记念，将来的世代，后来的人也不记念。” 这时候我就会怀念起五一假期在家里度过的那四天，我想那四天可能会作为十分珍贵的回忆，被我一再地以这样仿佛怅然若失的口吻谈论。那四天每天都一觉睡到下午一两点，醒来就躺在床上听着雨滴落在窗玻璃上咚咚咚咚地响、能听好几个小时，然后慢悠悠地走三公里到喜欢的茶餐厅去吃一天的第一餐，回家之后敲一会鼓，和相隔万里的朋友一起看电影、聊天，熬到很晚，然后睡觉，再醒来，又是一天，没有新事情。没有工作的必然。没有生存的必然。 几个月以来第一次打开了本博客使用的访客统计工具 Google Analytics，惊讶地看到「实时」一栏居然有数字。不知道两位朋友读的是什么呢？技术上比我优秀的人有太多，心境上比我平和的人有太多，做人比我会做的人也有太多。 上一篇正经的博文也有四五个月了。这个博客还会有技术文章吗？还有什么应该去写的事情呢？ ​ 如果明天就是世界末日，或者如果明天我就不再存在，还有什么应该去做的事情呢？","link":"/life/what-left-behind/"}],"tags":[{"name":"存储和分布式系统","slug":"存储和分布式系统","link":"/tags/%E5%AD%98%E5%82%A8%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"},{"name":"程序设计范式（paradigm）","slug":"程序设计范式（paradigm）","link":"/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F%EF%BC%88paradigm%EF%BC%89/"},{"name":"程序设计语言","slug":"程序设计语言","link":"/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"},{"name":"阿尔贝·加缪","slug":"阿尔贝·加缪","link":"/tags/%E9%98%BF%E5%B0%94%E8%B4%9D%C2%B7%E5%8A%A0%E7%BC%AA/"},{"name":"文学","slug":"文学","link":"/tags/%E6%96%87%E5%AD%A6/"},{"name":"总结","slug":"总结","link":"/tags/%E6%80%BB%E7%BB%93/"},{"name":"硬件编程","slug":"硬件编程","link":"/tags/%E7%A1%AC%E4%BB%B6%E7%BC%96%E7%A8%8B/"},{"name":"SystemVerilog","slug":"SystemVerilog","link":"/tags/SystemVerilog/"},{"name":"FPGA","slug":"FPGA","link":"/tags/FPGA/"},{"name":"矫情","slug":"矫情","link":"/tags/%E7%9F%AB%E6%83%85/"},{"name":"没什么用的回忆","slug":"没什么用的回忆","link":"/tags/%E6%B2%A1%E4%BB%80%E4%B9%88%E7%94%A8%E7%9A%84%E5%9B%9E%E5%BF%86/"},{"name":"科幻","slug":"科幻","link":"/tags/%E7%A7%91%E5%B9%BB/"},{"name":"爵士鼓","slug":"爵士鼓","link":"/tags/%E7%88%B5%E5%A3%AB%E9%BC%93/"},{"name":"架子鼓","slug":"架子鼓","link":"/tags/%E6%9E%B6%E5%AD%90%E9%BC%93/"},{"name":"音乐","slug":"音乐","link":"/tags/%E9%9F%B3%E4%B9%90/"},{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"翻译","slug":"翻译","link":"/tags/%E7%BF%BB%E8%AF%91/"},{"name":"演化生物学","slug":"演化生物学","link":"/tags/%E6%BC%94%E5%8C%96%E7%94%9F%E7%89%A9%E5%AD%A6/"},{"name":"生物学","slug":"生物学","link":"/tags/%E7%94%9F%E7%89%A9%E5%AD%A6/"},{"name":"不务正业","slug":"不务正业","link":"/tags/%E4%B8%8D%E5%8A%A1%E6%AD%A3%E4%B8%9A/"},{"name":"Rust","slug":"Rust","link":"/tags/Rust/"},{"name":"诗歌","slug":"诗歌","link":"/tags/%E8%AF%97%E6%AD%8C/"},{"name":"病毒学","slug":"病毒学","link":"/tags/%E7%97%85%E6%AF%92%E5%AD%A6/"}],"categories":[{"name":"programming","slug":"programming","link":"/categories/programming/"},{"name":"literature","slug":"literature","link":"/categories/literature/"},{"name":"life","slug":"life","link":"/categories/life/"},{"name":"hardware","slug":"hardware","link":"/categories/hardware/"},{"name":"notice","slug":"notice","link":"/categories/notice/"},{"name":"music","slug":"music","link":"/categories/music/"},{"name":"science","slug":"science","link":"/categories/science/"}]}